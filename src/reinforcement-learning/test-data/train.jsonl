{"Smelly Sample":"\tprotected void write(PackagerResult result) throws Exception {\n\t\twrite(result.getContainers());\n\t}\n","Method after Refactoring":"\tprotected void write(PackagerResult result) throws Exception {\n\t\twrite(result, true);\n\t}\n","Extracted Method":"\tprotected void write(PackagerResult result, boolean calculatePoints) throws Exception {\n\t\twrite(result.getContainers(), calculatePoints);\n\t}\n"}
{"Smelly Sample":"\tprotected void write(Container container) throws Exception {\n\t\twrite(Arrays.asList(container));\n\t}\n","Method after Refactoring":"\tprotected void write(Container container) throws Exception {\n\t\twrite(container, true);\n\t}\n","Extracted Method":"\tprotected void write(Container container, boolean calculatePoints) throws Exception {\n\t\twrite(Arrays.asList(container), calculatePoints);\n\t}\n"}
{"Smelly Sample":"\tprotected void write(List<Container> packList) throws Exception {\n\t\tDefaultPackagingResultVisualizerFactory p = new DefaultPackagingResultVisualizerFactory();\n\n\t\tFile file = new File(\"../viewer/public/assets/containers.json\");\n\t\tp.visualize(packList, file);\n\t}\n","Method after Refactoring":"\tprotected void write(List<Container> packList) throws Exception {\n\t\twrite(packList, true);\n\t}\n","Extracted Method":"\tprotected void write(List<Container> packList, boolean calculatePoints) throws Exception {\n\t\tDefaultPackagingResultVisualizerFactory p = new DefaultPackagingResultVisualizerFactory(calculatePoints);\n\n\t\tFile file = new File(\"../viewer/public/assets/containers.json\");\n\t\tp.visualize(packList, file);\n\t}\n"}
{"Smelly Sample":"\tpublic SELF isAlongsideY(Placement2D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY() && other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1) + \" or end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF isAlongsideY(Placement2D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY() && other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1) + \" or end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF isAlongsideX(Placement2D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() && other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1) + \" or end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF isAlongsideX(Placement2D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() && other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1) + \" or end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideX(Placement2D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideX(Placement2D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() ) {\n\t\t\tfailWithMessage(\"Expected end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() ) {\n\t\t\tfailWithMessage(\"Expected end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF isAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY() && other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1) + \" or end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF isAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY() && other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1) + \" or end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInZDimension() {\n\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF isAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY() && other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1) + \" or end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF isAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY() && other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1) + \" or end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF isAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() && other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1) + \" or end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF isAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() && other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1) + \" or end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInZDimension() {\n\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF isAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() && other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1) + \" or end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF isAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() && other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1) + \" or end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF isAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndZ() + 1 != other.getAbsoluteZ() && other.getAbsoluteEndZ() + 1 != actual.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected start z at \" + (other.getAbsoluteEndZ() + 1) + \" or end z at \" + (other.getAbsoluteZ() - 1));\n\t\t}\n\t\treturn myself;\n\t}\t\n","Method after Refactoring":"\tpublic SELF isAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndZ() + 1 != other.getAbsoluteZ() && other.getAbsoluteEndZ() + 1 != actual.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected start z at \" + (other.getAbsoluteEndZ() + 1) + \" or end z at \" + (other.getAbsoluteZ() - 1));\n\t\t}\n\t\treturn myself;\n\t}\t\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF isAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndZ() + 1 != other.getAbsoluteZ() && other.getAbsoluteEndZ() + 1 != actual.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected start z at \" + (other.getAbsoluteEndZ() + 1) + \" or end z at \" + (other.getAbsoluteZ() - 1));\n\t\t}\n\t\treturn myself;\n\t}\t\n","Method after Refactoring":"\tpublic SELF isAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndZ() + 1 != other.getAbsoluteZ() && other.getAbsoluteEndZ() + 1 != actual.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected start z at \" + (other.getAbsoluteEndZ() + 1) + \" or end z at \" + (other.getAbsoluteZ() - 1));\n\t\t}\n\t\treturn myself;\n\t}\t\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInZDimension() {\n\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndX() + 1 != actual.getAbsoluteX()) {\n\t\t\tfailWithMessage(\"Expected start x at \" + (other.getAbsoluteEndX() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInZDimension() {\n\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndY() + 1 != actual.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected start y at \" + (other.getAbsoluteEndY() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndZ() + 1 != actual.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected start z at \" + (other.getAbsoluteEndZ() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndZ() + 1 != actual.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected start z at \" + (other.getAbsoluteEndZ() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF followsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndZ() + 1 != actual.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected start z at \" + (other.getAbsoluteEndZ() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF followsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\tif (other.getAbsoluteEndZ() + 1 != actual.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected start z at \" + (other.getAbsoluteEndZ() + 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInZDimension() {\n\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideY(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndY() + 1 != other.getAbsoluteY()) {\n\t\t\tfailWithMessage(\"Expected end y at \" + (other.getAbsoluteY() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() ) {\n\t\t\tfailWithMessage(\"Expected end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() ) {\n\t\t\tfailWithMessage(\"Expected end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInZDimension() {\n\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in z dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() ) {\n\t\t\tfailWithMessage(\"Expected end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideX(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\tif(!isOverlapZ(other)) {\n\t\t\tfailWithNotOverlappingInZDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndX() + 1 != other.getAbsoluteX() ) {\n\t\t\tfailWithMessage(\"Expected end x at \" + (other.getAbsoluteX() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndZ() + 1 != other.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected end z at \" + (other.getAbsoluteZ() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndZ() + 1 != other.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected end z at \" + (other.getAbsoluteZ() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInXDimension() {\n\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic SELF preceedsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in x dimension\");\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndZ() + 1 != other.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected end z at \" + (other.getAbsoluteZ() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Method after Refactoring":"\tpublic SELF preceedsAlongsideZ(Placement3D other) {\n\t\tisNotNull();\n\t\t\n\t\tif(!isOverlapX(other)) {\n\t\t\tfailWithNotOverlappingInXDimension();\n\t\t}\n\t\tif(!isOverlapY(other)) {\n\t\t\tfailWithNotOverlappingInYDimension();\n\t\t}\n\t\t\n\t\tif (actual.getAbsoluteEndZ() + 1 != other.getAbsoluteZ()) {\n\t\t\tfailWithMessage(\"Expected end z at \" + (other.getAbsoluteZ() - 1));\n\t\t}\n\t\treturn myself;\n\t}\n","Extracted Method":"\tprivate void failWithNotOverlappingInYDimension() {\n\t\tfailWithMessage(\"Not overlapping in y dimension\");\n\t}\n"}
{"Smelly Sample":"\tpublic int nextPermutation() {\n\t\tSystem.arraycopy(reset, 0, rotations, ParallelPermutationRotationIteratorList.PADDING, reset.length);\n\n\t\tint resultIndex = nextPermutationImpl();\n\t\t\n\t\treturn returnPermuationWithinRangeOrMinusOne(resultIndex);\n\t}\n","Method after Refactoring":"\tpublic int nextPermutation() {\n\t\tresetRotations();\n\n\t\tint resultIndex = nextPermutationImpl();\n\t\t\n\t\treturn returnPermuationWithinRangeOrMinusOne(resultIndex);\n\t}\n","Extracted Method":"\tpublic void resetRotations() {\n\t\tSystem.arraycopy(reset, 0, rotations, ParallelPermutationRotationIteratorList.PADDING, reset.length);\n\t}\n"}
{"Smelly Sample":"\tpublic int nextPermutation(int maxIndex) {\n\t\t// reset rotations\n\t\tSystem.arraycopy(reset, 0, rotations, ParallelPermutationRotationIteratorList.PADDING, reset.length);\n\n\t\tint resultIndex = nextWorkUnitPermutation(permutations, maxIndex);\n\t\t\n\t\treturn returnPermuationWithinRangeOrMinusOne(resultIndex);\n\t}\n","Method after Refactoring":"\tpublic int nextPermutation(int maxIndex) {\n\t\t// reset rotations\n\t\tresetRotations();\n\n\t\tint resultIndex = nextWorkUnitPermutation(permutations, maxIndex);\n\t\t\n\t\treturn returnPermuationWithinRangeOrMinusOne(resultIndex);\n\t}\n","Extracted Method":"\tpublic void resetRotations() {\n\t\tSystem.arraycopy(reset, 0, rotations, ParallelPermutationRotationIteratorList.PADDING, reset.length);\n\t}\n"}
{"Smelly Sample":"\t@Override\n\tpublic int nextRotation() {\n\t\t// next rotation\n\t\tfor(int i = rotations.length - 1; i >= 0; i--) {\n\t\t\tif(rotations[i] < matrix[permutations[i]].getBoxes().length - 1) {\n\t\t\t\trotations[i]++;\n\n\t\t\t\tSystem.arraycopy(reset, 0, rotations, i + 1, rotations.length - (i + 1));\n\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n","Method after Refactoring":"\t@Override\n\tpublic int nextRotation() {\n\t\t// next rotation\n\t\treturn nextRotation(rotations.length - 1);\n\t}\n","Extracted Method":"\t@Override\n\tpublic int nextRotation(int maxIndex) {\n\t\t// next rotation\n\t\tfor(int i = maxIndex; i >= 0; i--) {\n\t\t\tif(rotations[i] < matrix[permutations[i]].getBoxes().length - 1) {\n\t\t\t\trotations[i]++;\n\n\t\t\t\tSystem.arraycopy(reset, 0, rotations, i + 1, rotations.length - (i + 1));\n\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n"}
{"Smelly Sample":"\tpublic boolean add(int index, P placement) {\n\t\t// overall approach:\n\t\t// Do not iterate over placements to find point max / mins, rather\n\t\t// project existing points. \n\t\t//  \n\t\t// project points swallowed by the placement, then delete them\n\t\t// project points shadowed by the placement to the other side\n\t\t// add points shadowed by the two new points (if they could be moved in the negative direction)\n\t\t// remove points which are eclipsed by others\n\t\t\n\t\t// keep track of placement borders, where possible\n\t\tPoint2D<P> source = values.get(index);\n\t\t\n\t\tboolean xSupport = source.isXSupport(source.getMinX());\n\t\tboolean ySupport = source.isYSupport(source.getMinY());\n\t\t\n\t\tint xx = placement.getAbsoluteEndX() + 1;\n\t\tint yy = placement.getAbsoluteEndY() + 1;\n\t\t\n\t\tvalues.flag(index);\n\t\t\n\t\t//       |\n\t\t//       |\n\t\t//       |        |---------------| \n\t\t//       |       \n\t\t//       |        |               |\n\t\t//       |    \n\t\t//  minY |        x════════════════         <---- support for a range of x (at minY)\n\t\t//       |                     \n\t\t//       |                    \n\t\t//       |--------------------------\n\t\t//               minX             maxX\n\t\t\n\t\tboolean xxSupport = xSupport && source.isXSupport(xx); // i.e. is source minY also minY at XX?\n\n\t\t//\n\t\t// vmaxY |                    \n\t\t//       |          \n\t\t//  yy   |        ║ - - - |\n\t\t//       |        ║\n\t\t//       |        ║       |\n\t\t//       |        ║              <-- support for a range of Y (at minX)\n\t\t//       |        ║       |\n\t\t//       |        ║  \n\t\t//  minY |        x - - - |\n\t\t//       |\n\t\t//       |-----------------------------\n\t\t//               minX    maxX\n\t\t//   \n\t\t\n\t\tboolean yySupport = ySupport && source.isYSupport(yy); // i.e. is source minX also minX at YY?\n\n\t\t//    y\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t// yy |         |-------|        |\n\t\t//    | a       |     b |        |\n\t\t//    |         |  b    |        |\n\t\t//    | a       |       |        |\n\t\t//    |     a   | b     |        |\n\t\t//    a---------b-------|        |\n\t\t//    |         |   c            |\n\t\t//    |         |     c          |\n\t\t//    |         |  c             |\n\t\t//    |         |      c         |\n\t\t//    |---------c----------------|--- x\n\t\t//\t\t               xx \n\t\t//\n\t\t// a - shadowed x\n\t\t// b - swallowed\n\t\t// c - shadowed y\n\t\t//\n\t\t// Copy maxX and maxY from existing points:\n\t\t// a & b used to determine maxX at yy\n\t\t// b & c used to determine maxY at xx\n\t\t\n\t\t// determine start and end index based on previous sort (in x direction)\n\t\t\n\t\tint pointIndex;\n\t\tif(yySupport) {\n\t\t\t// b and c only\n\t\t\tpointIndex = binarySearchMinusMinX(placement.getAbsoluteX());\n\t\t} else {\n\t\t\tpointIndex = 0;\n\t\t}\n\t\tint endIndex = binarySearchPlusMinX(placement.getAbsoluteEndX());\n\t\t\n\t\tnegativeMoveToXX.ensureCapacity(endIndex);\n\t\tnegativeMoveToYY.ensureCapacity(endIndex);\n\t\t\n\t\taddXX.ensureAdditionalCapacity(values.size());\n\t\taddYY.ensureAdditionalCapacity(values.size());\n\t\t\n\t\tfor(int i = pointIndex; i < endIndex; i++) {\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\n\t\t\tif(point.getMinY() > placement.getAbsoluteEndY()) {\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |  *           *        *\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          |      |     *\n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       *\n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz)\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |  *  *|\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\tif(point.getMinX() >= source.getMinX() && point.getMinY() >= source.getMinY()) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          | *  * |     \n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\n\t\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t\tnegativeMoveToXX.add(i);\n\t\t\t\t}\n\t\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t\tnegativeMoveToYY.add(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalues.flag(i);\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(xxSupport && yySupport) {\n\t\t\t\t// do not move points to xx, yy, or zz\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║------|\n\t\t\t\t// |   *      ║      |\n\t\t\t\t// |      *   ║══════════\n\t\t\t\t// |                       \n\t\t\t\t// |    *    *    *   \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t// \n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz), excluding the placement itself\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |      |\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\t// does any point intersect the xx, yy or zz planes?\n\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t// yz plane\n\t\t\t\tnegativeMoveToXX.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t// xz plane\n\t\t\t\tnegativeMoveToYY.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!negativeMoveToXX.isEmpty()) {\n\t\t\tnegativeMoveToXX.sortThis(COMPARATOR_MOVE_TO_XX);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < negativeMoveToXX.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(negativeMoveToXX.get(i));\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addXX.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addXX.get(k);\n\t\t\t\t\tif(add.eclipsesMovedX(p, xx)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// note: the new point might shadow one of the previous points\n\t\t\t\tPoint2D<P> moveX = p.moveX(xx, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddXX.add(moveX);\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(!negativeMoveToYY.isEmpty()) {\n\t\t\tnegativeMoveToYY.sortThis(COMPARATOR_MOVE_TO_YY);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < negativeMoveToYY.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(negativeMoveToYY.get(i));\n\t\t\t\t\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addYY.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addYY.get(k);\n\t\t\t\t\tif(add.eclipsesMovedY(p, yy)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPoint2D<P> moveY = p.moveY(yy, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddYY.add(moveY);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tif(xxSupport && yySupport) {\n\t\t\tfor (int i = pointIndex; i < endIndex; i++) {\n\t\t\t\tif(values.isFlag(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\tif(point.getMinY() < placement.getAbsoluteY() && withinX(point.getMinX(), placement)) {\n\t\t\t\t\tif(point.getMaxY() >= placement.getAbsoluteY()) {\n\t\t\t\t\t\tpoint.setMaxY(placement.getAbsoluteY() - 1);\n\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(point.getMinX() < placement.getAbsoluteX() && withinY(point.getMinY(), placement)) {\n\t\t\t\t\tif(point.getMaxX() >= placement.getAbsoluteX()) {\n\t\t\t\t\t\tpoint.setMaxX(placement.getAbsoluteX() - 1);\n\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconstrainFloatingMax(placement, endIndex);\t\t\t\n\t\t}\n\t\t\n\t\tendIndex -= values.removeFlagged();\n\t\t\n\t\tplacements.add(placement);\n\t\t\n\t\tint added = addXX.size() + addYY.size();\n\t\t// the new points have x coordinate between zero and xx. \n\t\t// insert them at the start of the existing data\n\t\t// so that the sorting algorithm does not have to do a full sort\n\t\t// rather only sort points with x coordinates from 0 to xx.\n\t\tvalues.ensureAdditionalCapacity(added);\n\t\t\n\t\t// insert xx last, because it has the highest x coordinate\n\t\tvalues.move(added);\n\t\tvalues.setAll(addYY, 0);\n\t\tvalues.setAll(addXX, addYY.size());\n\n\t\tremoveEclipsed(added);\n\t\t\n\t\tendIndex += added - values.removeFlagged();\n\n\t\t// make sure to capture all point <= xx\n\t\twhile(endIndex < values.size() && values.get(endIndex).getMinX() <= xx) {\n\t\t\tendIndex++;\n\t\t}\n\t\t\n\t\tvalues.sort(Point2D.COMPARATOR_X_THEN_Y, endIndex);\n\n\t\tnegativeMoveToXX.clear();\n\t\tnegativeMoveToYY.clear();\n\t\t\n\t\taddXX.clear();\n\t\taddYY.clear();\n\t\t\n\t\treturn !values.isEmpty();\n\t}\n","Method after Refactoring":"\tpublic boolean add(int index, P placement) {\n\t\t// overall approach:\n\t\t// Do not iterate over placements to find point max / mins, rather\n\t\t// project existing points. \n\t\t//  \n\t\t// project points swallowed by the placement, then delete them\n\t\t// project points shadowed by the placement to the other side\n\t\t// add points shadowed by the two new points (if they could be moved in the negative direction)\n\t\t// remove points which are eclipsed by others\n\t\t\n\t\t// keep track of placement borders, where possible\n\t\tPoint2D<P> source = values.get(index);\n\t\t\n\t\tboolean xSupport = source.isXSupport(source.getMinX());\n\t\tboolean ySupport = source.isYSupport(source.getMinY());\n\t\t\n\t\tint xx = placement.getAbsoluteEndX() + 1;\n\t\tint yy = placement.getAbsoluteEndY() + 1;\n\t\t\n\t\tvalues.flag(index);\n\t\t\n\t\t//       |\n\t\t//       |\n\t\t//       |        |---------------| \n\t\t//       |       \n\t\t//       |        |               |\n\t\t//       |    \n\t\t//  minY |        x════════════════         <---- support for a range of x (at minY)\n\t\t//       |                     \n\t\t//       |                    \n\t\t//       |--------------------------\n\t\t//               minX             maxX\n\t\t\n\t\tboolean xxSupport = xSupport && source.isXSupport(xx); // i.e. is source minY also minY at XX?\n\n\t\t//\n\t\t// vmaxY |                    \n\t\t//       |          \n\t\t//  yy   |        ║ - - - |\n\t\t//       |        ║\n\t\t//       |        ║       |\n\t\t//       |        ║              <-- support for a range of Y (at minX)\n\t\t//       |        ║       |\n\t\t//       |        ║  \n\t\t//  minY |        x - - - |\n\t\t//       |\n\t\t//       |-----------------------------\n\t\t//               minX    maxX\n\t\t//   \n\t\t\n\t\tboolean yySupport = ySupport && source.isYSupport(yy); // i.e. is source minX also minX at YY?\n\n\t\t//    y\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t// yy |         |-------|        |\n\t\t//    | a       |     b |        |\n\t\t//    |         |  b    |        |\n\t\t//    | a       |       |        |\n\t\t//    |     a   | b     |        |\n\t\t//    a---------b-------|        |\n\t\t//    |         |   c            |\n\t\t//    |         |     c          |\n\t\t//    |         |  c             |\n\t\t//    |         |      c         |\n\t\t//    |---------c----------------|--- x\n\t\t//\t\t               xx \n\t\t//\n\t\t// a - shadowed x\n\t\t// b - swallowed\n\t\t// c - shadowed y\n\t\t//\n\t\t// Copy maxX and maxY from existing points:\n\t\t// a & b used to determine maxX at yy\n\t\t// b & c used to determine maxY at xx\n\t\t\n\t\t// determine start and end index based on previous sort (in x direction)\n\t\t\n\t\tint pointIndex;\n\t\tif(yySupport) {\n\t\t\t// b and c only\n\t\t\t\n\t\t\t// already have index for point at absoluteX\n\t\t\tpointIndex = index;\n        \twhile(pointIndex > 0 && values.get(pointIndex - 1).getMinX() == placement.getAbsoluteX()) {\n        \t\tpointIndex--;\n        \t}\n\t\t} else {\n\t\t\tpointIndex = 0;\n\t\t}\n\t\tint endIndex = binarySearchPlusMinX(placement.getAbsoluteEndX());\n\t\t\n\t\tmoveToXX.ensureCapacity(endIndex);\n\t\tmoveToYY.ensureCapacity(endIndex);\n\t\t\n\t\taddXX.ensureAdditionalCapacity(values.size());\n\t\taddYY.ensureAdditionalCapacity(values.size());\n\t\t\n\t\tfor(int i = pointIndex; i < endIndex; i++) {\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\n\t\t\tif(point.getMinY() > placement.getAbsoluteEndY()) {\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |  *           *        *\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          |      |     *\n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       *\n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz)\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |  *  *|\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\tif(point.getMinX() >= source.getMinX() && point.getMinY() >= source.getMinY()) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          | *  * |     \n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\n\t\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t\tmoveToXX.add(i);\n\t\t\t\t}\n\t\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t\tmoveToYY.add(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalues.flag(i);\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(xxSupport && yySupport) {\n\t\t\t\t// do not move points to xx, yy, or zz\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║------|\n\t\t\t\t// |   *      ║      |\n\t\t\t\t// |      *   ║══════════\n\t\t\t\t// |                       \n\t\t\t\t// |    *    *    *   \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t// \n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz), excluding the placement itself\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |      |\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\t// does any point intersect the xx, yy or zz planes?\n\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t// yz plane\n\t\t\t\tmoveToXX.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t// xz plane\n\t\t\t\tmoveToYY.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!moveToXX.isEmpty()) {\n\t\t\tmoveToXX.sortThis(COMPARATOR_MOVE_TO_XX);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < moveToXX.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(moveToXX.get(i));\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addXX.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addXX.get(k);\n\t\t\t\t\tif(add.eclipsesMovedX(p, xx)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// note: the new point might shadow one of the previous points\n\t\t\t\tPoint2D<P> moveX = p.moveX(xx, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddXX.add(moveX);\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(!moveToYY.isEmpty()) {\n\t\t\tmoveToYY.sortThis(COMPARATOR_MOVE_TO_YY);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < moveToYY.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(moveToYY.get(i));\n\t\t\t\t\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addYY.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addYY.get(k);\n\t\t\t\t\tif(add.eclipsesMovedY(p, yy)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPoint2D<P> moveY = p.moveY(yy, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddYY.add(moveY);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tif(xxSupport && yySupport) {\n\t\t\t// no constrain necessary\n\t\t} else if(yySupport) {\n\t\t\t\n\t\t\t//\n\t\t\t// vmaxY |                    \n\t\t\t//       |          \n\t\t\t//  yy   |        ║ - - - |\n\t\t\t//       |        ║\n\t\t\t//       |        ║       |\n\t\t\t//       |        ║              \n\t\t\t//       |        ║       |\n\t\t\t//       |        ║  \n\t\t\t//  minY |        x - - - |\n\t\t\t//       |          *   *\n\t\t\t//       |        *   *\n\t\t\t//       |          *    *\n\t\t\t//       |-----------------------------\n\t\t\t//               minX    maxX\n\t\t\t//   \n\t\t\t// so only those points between 0 and minY \n\t\t\t// and between minX and maxX need to be constrained\n\t\t\t\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainMaxYWithClone(placement, pointIndex, endIndex);\n\t\t\t} else {\n\t\t\t\tconstrainMaxY(placement, pointIndex, endIndex);\n\t\t\t}\n\t\t} else if(xxSupport) {\n\t\t\t\n\t\t\t//       |\n\t\t\t//       |\n\t\t\t//       |     *  |---------------| \n\t\t\t//       | *     \n\t\t\t//       |    *   |               |\n\t\t\t//       |  * \n\t\t\t//  minY |    *   x════════════════        \n\t\t\t//       |                     \n\t\t\t//       |                    \n\t\t\t//       |--------------------------\n\t\t\t//               minX             maxX\n\t\t\t//\n\t\t\t// so only those points between 0 and minX \n\t\t\t// and between minY and maxY need to be constrained\n\t\t\t\n\t\t\tpointIndex = index;\n        \twhile(pointIndex > 0 && values.get(pointIndex - 1).getMinX() == placement.getAbsoluteX()) {\n        \t\tpointIndex--;\n        \t}\n\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainMaxXWithClone(placement, 0, pointIndex);\n\t\t\t} else {\n\t\t\t\tconstrainMaxX(placement, 0, pointIndex);\n\t\t\t}\n\t\t} else {\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainFloatingMaxWithClone(placement, endIndex);\n\t\t\t} else {\n\t\t\t\tconstrainFloatingMax(placement, endIndex);\n\t\t\t}\n\t\t}\n\t\t\n\t\tendIndex -= values.removeFlagged();\n\t\t\n\t\tplacements.add(placement);\n\t\t\n\t\tint added = addXX.size() + addYY.size();\n\t\t// the new points have x coordinate between zero and xx. \n\t\t// insert them at the start of the existing data\n\t\t// so that the sorting algorithm does not have to do a full sort\n\t\t// rather only sort points with x coordinates from 0 to xx.\n\t\tvalues.ensureAdditionalCapacity(added);\n\t\t\n\t\t// insert xx last, because it has the highest x coordinate\n\t\tvalues.move(added);\n\t\tvalues.setAll(addYY, 0);\n\t\tvalues.setAll(addXX, addYY.size());\n\n\t\tremoveEclipsed(added);\n\t\t\n\t\tendIndex += added - values.removeFlagged();\n\n\t\t// make sure to capture all point <= xx\n\t\twhile(endIndex < values.size() && values.get(endIndex).getMinX() <= xx) {\n\t\t\tendIndex++;\n\t\t}\n\t\t\n\t\tvalues.sort(Point2D.COMPARATOR_X_THEN_Y, endIndex);\n\n\t\tmoveToXX.clear();\n\t\tmoveToYY.clear();\n\t\t\n\t\taddXX.clear();\n\t\taddYY.clear();\n\t\t\n\t\treturn !values.isEmpty();\n\t}\n","Extracted Method":"\tprivate void constrainMaxXWithClone(P placement, int pointIndex, int endIndex) {\n\t\tfor (int i = pointIndex; i < endIndex; i++) {\n\t\t\tif(values.isFlag(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\tif(point.getMinX() < placement.getAbsoluteX() && withinY(point.getMinY(), placement)) {\n\t\t\t\tif(point.getMaxX() >= placement.getAbsoluteX()) {\n\t\t\t\t\tint limitX = placement.getAbsoluteX() - 1;\n\t\t\t\t\tif(!isConstrainedAtMaxX(point, limitX)) {\n\t\t\t\t\t\tPoint2D<P> clone = point.clone(limitX, point.getMaxY());\n\t\t\t\t\t\t\n\t\t\t\t\t\taddXX.add(clone);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tvalues.flag(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n"}
{"Smelly Sample":"\tpublic boolean add(int index, P placement) {\n\t\t// overall approach:\n\t\t// Do not iterate over placements to find point max / mins, rather\n\t\t// project existing points. \n\t\t//  \n\t\t// project points swallowed by the placement, then delete them\n\t\t// project points shadowed by the placement to the other side\n\t\t// add points shadowed by the two new points (if they could be moved in the negative direction)\n\t\t// remove points which are eclipsed by others\n\t\t\n\t\t// keep track of placement borders, where possible\n\t\tPoint2D<P> source = values.get(index);\n\t\t\n\t\tboolean xSupport = source.isXSupport(source.getMinX());\n\t\tboolean ySupport = source.isYSupport(source.getMinY());\n\t\t\n\t\tint xx = placement.getAbsoluteEndX() + 1;\n\t\tint yy = placement.getAbsoluteEndY() + 1;\n\t\t\n\t\tvalues.flag(index);\n\t\t\n\t\t//       |\n\t\t//       |\n\t\t//       |        |---------------| \n\t\t//       |       \n\t\t//       |        |               |\n\t\t//       |    \n\t\t//  minY |        x════════════════         <---- support for a range of x (at minY)\n\t\t//       |                     \n\t\t//       |                    \n\t\t//       |--------------------------\n\t\t//               minX             maxX\n\t\t\n\t\tboolean xxSupport = xSupport && source.isXSupport(xx); // i.e. is source minY also minY at XX?\n\n\t\t//\n\t\t// vmaxY |                    \n\t\t//       |          \n\t\t//  yy   |        ║ - - - |\n\t\t//       |        ║\n\t\t//       |        ║       |\n\t\t//       |        ║              <-- support for a range of Y (at minX)\n\t\t//       |        ║       |\n\t\t//       |        ║  \n\t\t//  minY |        x - - - |\n\t\t//       |\n\t\t//       |-----------------------------\n\t\t//               minX    maxX\n\t\t//   \n\t\t\n\t\tboolean yySupport = ySupport && source.isYSupport(yy); // i.e. is source minX also minX at YY?\n\n\t\t//    y\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t// yy |         |-------|        |\n\t\t//    | a       |     b |        |\n\t\t//    |         |  b    |        |\n\t\t//    | a       |       |        |\n\t\t//    |     a   | b     |        |\n\t\t//    a---------b-------|        |\n\t\t//    |         |   c            |\n\t\t//    |         |     c          |\n\t\t//    |         |  c             |\n\t\t//    |         |      c         |\n\t\t//    |---------c----------------|--- x\n\t\t//\t\t               xx \n\t\t//\n\t\t// a - shadowed x\n\t\t// b - swallowed\n\t\t// c - shadowed y\n\t\t//\n\t\t// Copy maxX and maxY from existing points:\n\t\t// a & b used to determine maxX at yy\n\t\t// b & c used to determine maxY at xx\n\t\t\n\t\t// determine start and end index based on previous sort (in x direction)\n\t\t\n\t\tint pointIndex;\n\t\tif(yySupport) {\n\t\t\t// b and c only\n\t\t\tpointIndex = binarySearchMinusMinX(placement.getAbsoluteX());\n\t\t} else {\n\t\t\tpointIndex = 0;\n\t\t}\n\t\tint endIndex = binarySearchPlusMinX(placement.getAbsoluteEndX());\n\t\t\n\t\tnegativeMoveToXX.ensureCapacity(endIndex);\n\t\tnegativeMoveToYY.ensureCapacity(endIndex);\n\t\t\n\t\taddXX.ensureAdditionalCapacity(values.size());\n\t\taddYY.ensureAdditionalCapacity(values.size());\n\t\t\n\t\tfor(int i = pointIndex; i < endIndex; i++) {\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\n\t\t\tif(point.getMinY() > placement.getAbsoluteEndY()) {\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |  *           *        *\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          |      |     *\n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       *\n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz)\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |  *  *|\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\tif(point.getMinX() >= source.getMinX() && point.getMinY() >= source.getMinY()) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          | *  * |     \n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\n\t\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t\tnegativeMoveToXX.add(i);\n\t\t\t\t}\n\t\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t\tnegativeMoveToYY.add(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalues.flag(i);\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(xxSupport && yySupport) {\n\t\t\t\t// do not move points to xx, yy, or zz\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║------|\n\t\t\t\t// |   *      ║      |\n\t\t\t\t// |      *   ║══════════\n\t\t\t\t// |                       \n\t\t\t\t// |    *    *    *   \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t// \n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz), excluding the placement itself\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |      |\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\t// does any point intersect the xx, yy or zz planes?\n\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t// yz plane\n\t\t\t\tnegativeMoveToXX.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t// xz plane\n\t\t\t\tnegativeMoveToYY.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!negativeMoveToXX.isEmpty()) {\n\t\t\tnegativeMoveToXX.sortThis(COMPARATOR_MOVE_TO_XX);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < negativeMoveToXX.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(negativeMoveToXX.get(i));\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addXX.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addXX.get(k);\n\t\t\t\t\tif(add.eclipsesMovedX(p, xx)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// note: the new point might shadow one of the previous points\n\t\t\t\tPoint2D<P> moveX = p.moveX(xx, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddXX.add(moveX);\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(!negativeMoveToYY.isEmpty()) {\n\t\t\tnegativeMoveToYY.sortThis(COMPARATOR_MOVE_TO_YY);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < negativeMoveToYY.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(negativeMoveToYY.get(i));\n\t\t\t\t\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addYY.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addYY.get(k);\n\t\t\t\t\tif(add.eclipsesMovedY(p, yy)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPoint2D<P> moveY = p.moveY(yy, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddYY.add(moveY);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tif(xxSupport && yySupport) {\n\t\t\tfor (int i = pointIndex; i < endIndex; i++) {\n\t\t\t\tif(values.isFlag(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\tif(point.getMinY() < placement.getAbsoluteY() && withinX(point.getMinX(), placement)) {\n\t\t\t\t\tif(point.getMaxY() >= placement.getAbsoluteY()) {\n\t\t\t\t\t\tpoint.setMaxY(placement.getAbsoluteY() - 1);\n\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(point.getMinX() < placement.getAbsoluteX() && withinY(point.getMinY(), placement)) {\n\t\t\t\t\tif(point.getMaxX() >= placement.getAbsoluteX()) {\n\t\t\t\t\t\tpoint.setMaxX(placement.getAbsoluteX() - 1);\n\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconstrainFloatingMax(placement, endIndex);\t\t\t\n\t\t}\n\t\t\n\t\tendIndex -= values.removeFlagged();\n\t\t\n\t\tplacements.add(placement);\n\t\t\n\t\tint added = addXX.size() + addYY.size();\n\t\t// the new points have x coordinate between zero and xx. \n\t\t// insert them at the start of the existing data\n\t\t// so that the sorting algorithm does not have to do a full sort\n\t\t// rather only sort points with x coordinates from 0 to xx.\n\t\tvalues.ensureAdditionalCapacity(added);\n\t\t\n\t\t// insert xx last, because it has the highest x coordinate\n\t\tvalues.move(added);\n\t\tvalues.setAll(addYY, 0);\n\t\tvalues.setAll(addXX, addYY.size());\n\n\t\tremoveEclipsed(added);\n\t\t\n\t\tendIndex += added - values.removeFlagged();\n\n\t\t// make sure to capture all point <= xx\n\t\twhile(endIndex < values.size() && values.get(endIndex).getMinX() <= xx) {\n\t\t\tendIndex++;\n\t\t}\n\t\t\n\t\tvalues.sort(Point2D.COMPARATOR_X_THEN_Y, endIndex);\n\n\t\tnegativeMoveToXX.clear();\n\t\tnegativeMoveToYY.clear();\n\t\t\n\t\taddXX.clear();\n\t\taddYY.clear();\n\t\t\n\t\treturn !values.isEmpty();\n\t}\n","Method after Refactoring":"\tpublic boolean add(int index, P placement) {\n\t\t// overall approach:\n\t\t// Do not iterate over placements to find point max / mins, rather\n\t\t// project existing points. \n\t\t//  \n\t\t// project points swallowed by the placement, then delete them\n\t\t// project points shadowed by the placement to the other side\n\t\t// add points shadowed by the two new points (if they could be moved in the negative direction)\n\t\t// remove points which are eclipsed by others\n\t\t\n\t\t// keep track of placement borders, where possible\n\t\tPoint2D<P> source = values.get(index);\n\t\t\n\t\tboolean xSupport = source.isXSupport(source.getMinX());\n\t\tboolean ySupport = source.isYSupport(source.getMinY());\n\t\t\n\t\tint xx = placement.getAbsoluteEndX() + 1;\n\t\tint yy = placement.getAbsoluteEndY() + 1;\n\t\t\n\t\tvalues.flag(index);\n\t\t\n\t\t//       |\n\t\t//       |\n\t\t//       |        |---------------| \n\t\t//       |       \n\t\t//       |        |               |\n\t\t//       |    \n\t\t//  minY |        x════════════════         <---- support for a range of x (at minY)\n\t\t//       |                     \n\t\t//       |                    \n\t\t//       |--------------------------\n\t\t//               minX             maxX\n\t\t\n\t\tboolean xxSupport = xSupport && source.isXSupport(xx); // i.e. is source minY also minY at XX?\n\n\t\t//\n\t\t// vmaxY |                    \n\t\t//       |          \n\t\t//  yy   |        ║ - - - |\n\t\t//       |        ║\n\t\t//       |        ║       |\n\t\t//       |        ║              <-- support for a range of Y (at minX)\n\t\t//       |        ║       |\n\t\t//       |        ║  \n\t\t//  minY |        x - - - |\n\t\t//       |\n\t\t//       |-----------------------------\n\t\t//               minX    maxX\n\t\t//   \n\t\t\n\t\tboolean yySupport = ySupport && source.isYSupport(yy); // i.e. is source minX also minX at YY?\n\n\t\t//    y\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t// yy |         |-------|        |\n\t\t//    | a       |     b |        |\n\t\t//    |         |  b    |        |\n\t\t//    | a       |       |        |\n\t\t//    |     a   | b     |        |\n\t\t//    a---------b-------|        |\n\t\t//    |         |   c            |\n\t\t//    |         |     c          |\n\t\t//    |         |  c             |\n\t\t//    |         |      c         |\n\t\t//    |---------c----------------|--- x\n\t\t//\t\t               xx \n\t\t//\n\t\t// a - shadowed x\n\t\t// b - swallowed\n\t\t// c - shadowed y\n\t\t//\n\t\t// Copy maxX and maxY from existing points:\n\t\t// a & b used to determine maxX at yy\n\t\t// b & c used to determine maxY at xx\n\t\t\n\t\t// determine start and end index based on previous sort (in x direction)\n\t\t\n\t\tint pointIndex;\n\t\tif(yySupport) {\n\t\t\t// b and c only\n\t\t\t\n\t\t\t// already have index for point at absoluteX\n\t\t\tpointIndex = index;\n        \twhile(pointIndex > 0 && values.get(pointIndex - 1).getMinX() == placement.getAbsoluteX()) {\n        \t\tpointIndex--;\n        \t}\n\t\t} else {\n\t\t\tpointIndex = 0;\n\t\t}\n\t\tint endIndex = binarySearchPlusMinX(placement.getAbsoluteEndX());\n\t\t\n\t\tmoveToXX.ensureCapacity(endIndex);\n\t\tmoveToYY.ensureCapacity(endIndex);\n\t\t\n\t\taddXX.ensureAdditionalCapacity(values.size());\n\t\taddYY.ensureAdditionalCapacity(values.size());\n\t\t\n\t\tfor(int i = pointIndex; i < endIndex; i++) {\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\n\t\t\tif(point.getMinY() > placement.getAbsoluteEndY()) {\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |  *           *        *\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          |      |     *\n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       *\n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz)\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |  *  *|\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\tif(point.getMinX() >= source.getMinX() && point.getMinY() >= source.getMinY()) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          | *  * |     \n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\n\t\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t\tmoveToXX.add(i);\n\t\t\t\t}\n\t\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t\tmoveToYY.add(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalues.flag(i);\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(xxSupport && yySupport) {\n\t\t\t\t// do not move points to xx, yy, or zz\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║------|\n\t\t\t\t// |   *      ║      |\n\t\t\t\t// |      *   ║══════════\n\t\t\t\t// |                       \n\t\t\t\t// |    *    *    *   \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t// \n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz), excluding the placement itself\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |      |\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\t// does any point intersect the xx, yy or zz planes?\n\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t// yz plane\n\t\t\t\tmoveToXX.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t// xz plane\n\t\t\t\tmoveToYY.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!moveToXX.isEmpty()) {\n\t\t\tmoveToXX.sortThis(COMPARATOR_MOVE_TO_XX);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < moveToXX.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(moveToXX.get(i));\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addXX.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addXX.get(k);\n\t\t\t\t\tif(add.eclipsesMovedX(p, xx)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// note: the new point might shadow one of the previous points\n\t\t\t\tPoint2D<P> moveX = p.moveX(xx, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddXX.add(moveX);\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(!moveToYY.isEmpty()) {\n\t\t\tmoveToYY.sortThis(COMPARATOR_MOVE_TO_YY);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < moveToYY.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(moveToYY.get(i));\n\t\t\t\t\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addYY.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addYY.get(k);\n\t\t\t\t\tif(add.eclipsesMovedY(p, yy)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPoint2D<P> moveY = p.moveY(yy, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddYY.add(moveY);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tif(xxSupport && yySupport) {\n\t\t\t// no constrain necessary\n\t\t} else if(yySupport) {\n\t\t\t\n\t\t\t//\n\t\t\t// vmaxY |                    \n\t\t\t//       |          \n\t\t\t//  yy   |        ║ - - - |\n\t\t\t//       |        ║\n\t\t\t//       |        ║       |\n\t\t\t//       |        ║              \n\t\t\t//       |        ║       |\n\t\t\t//       |        ║  \n\t\t\t//  minY |        x - - - |\n\t\t\t//       |          *   *\n\t\t\t//       |        *   *\n\t\t\t//       |          *    *\n\t\t\t//       |-----------------------------\n\t\t\t//               minX    maxX\n\t\t\t//   \n\t\t\t// so only those points between 0 and minY \n\t\t\t// and between minX and maxX need to be constrained\n\t\t\t\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainMaxYWithClone(placement, pointIndex, endIndex);\n\t\t\t} else {\n\t\t\t\tconstrainMaxY(placement, pointIndex, endIndex);\n\t\t\t}\n\t\t} else if(xxSupport) {\n\t\t\t\n\t\t\t//       |\n\t\t\t//       |\n\t\t\t//       |     *  |---------------| \n\t\t\t//       | *     \n\t\t\t//       |    *   |               |\n\t\t\t//       |  * \n\t\t\t//  minY |    *   x════════════════        \n\t\t\t//       |                     \n\t\t\t//       |                    \n\t\t\t//       |--------------------------\n\t\t\t//               minX             maxX\n\t\t\t//\n\t\t\t// so only those points between 0 and minX \n\t\t\t// and between minY and maxY need to be constrained\n\t\t\t\n\t\t\tpointIndex = index;\n        \twhile(pointIndex > 0 && values.get(pointIndex - 1).getMinX() == placement.getAbsoluteX()) {\n        \t\tpointIndex--;\n        \t}\n\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainMaxXWithClone(placement, 0, pointIndex);\n\t\t\t} else {\n\t\t\t\tconstrainMaxX(placement, 0, pointIndex);\n\t\t\t}\n\t\t} else {\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainFloatingMaxWithClone(placement, endIndex);\n\t\t\t} else {\n\t\t\t\tconstrainFloatingMax(placement, endIndex);\n\t\t\t}\n\t\t}\n\t\t\n\t\tendIndex -= values.removeFlagged();\n\t\t\n\t\tplacements.add(placement);\n\t\t\n\t\tint added = addXX.size() + addYY.size();\n\t\t// the new points have x coordinate between zero and xx. \n\t\t// insert them at the start of the existing data\n\t\t// so that the sorting algorithm does not have to do a full sort\n\t\t// rather only sort points with x coordinates from 0 to xx.\n\t\tvalues.ensureAdditionalCapacity(added);\n\t\t\n\t\t// insert xx last, because it has the highest x coordinate\n\t\tvalues.move(added);\n\t\tvalues.setAll(addYY, 0);\n\t\tvalues.setAll(addXX, addYY.size());\n\n\t\tremoveEclipsed(added);\n\t\t\n\t\tendIndex += added - values.removeFlagged();\n\n\t\t// make sure to capture all point <= xx\n\t\twhile(endIndex < values.size() && values.get(endIndex).getMinX() <= xx) {\n\t\t\tendIndex++;\n\t\t}\n\t\t\n\t\tvalues.sort(Point2D.COMPARATOR_X_THEN_Y, endIndex);\n\n\t\tmoveToXX.clear();\n\t\tmoveToYY.clear();\n\t\t\n\t\taddXX.clear();\n\t\taddYY.clear();\n\t\t\n\t\treturn !values.isEmpty();\n\t}\n","Extracted Method":"\tprivate void constrainMaxYWithClone(P placement, int pointIndex, int endIndex) {\n\t\tfor (int i = pointIndex; i < endIndex; i++) {\n\t\t\tif(values.isFlag(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\tif(point.getMinY() < placement.getAbsoluteY() && withinX(point.getMinX(), placement)) {\n\t\t\t\tif(point.getMaxY() >= placement.getAbsoluteY()) {\n\t\t\t\t\tint limitY = placement.getAbsoluteY() - 1;\n\t\t\t\t\tif(!isConstrainedAtMaxY(point, limitY)) {\n\t\t\t\t\t\tPoint2D<P> clone = point.clone(point.getMaxX(), limitY);\n\t\t\t\t\t\t\n\t\t\t\t\t\taddXX.add(clone);\n\t\t\t\t\t}\n\t\t\t\t\tvalues.flag(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n"}
{"Smelly Sample":"\tpublic boolean add(int index, P placement) {\n\t\t// overall approach:\n\t\t// Do not iterate over placements to find point max / mins, rather\n\t\t// project existing points. \n\t\t//  \n\t\t// project points swallowed by the placement, then delete them\n\t\t// project points shadowed by the placement to the other side\n\t\t// add points shadowed by the two new points (if they could be moved in the negative direction)\n\t\t// remove points which are eclipsed by others\n\t\t\n\t\t// keep track of placement borders, where possible\n\t\tPoint2D<P> source = values.get(index);\n\t\t\n\t\tboolean xSupport = source.isXSupport(source.getMinX());\n\t\tboolean ySupport = source.isYSupport(source.getMinY());\n\t\t\n\t\tint xx = placement.getAbsoluteEndX() + 1;\n\t\tint yy = placement.getAbsoluteEndY() + 1;\n\t\t\n\t\tvalues.flag(index);\n\t\t\n\t\t//       |\n\t\t//       |\n\t\t//       |        |---------------| \n\t\t//       |       \n\t\t//       |        |               |\n\t\t//       |    \n\t\t//  minY |        x════════════════         <---- support for a range of x (at minY)\n\t\t//       |                     \n\t\t//       |                    \n\t\t//       |--------------------------\n\t\t//               minX             maxX\n\t\t\n\t\tboolean xxSupport = xSupport && source.isXSupport(xx); // i.e. is source minY also minY at XX?\n\n\t\t//\n\t\t// vmaxY |                    \n\t\t//       |          \n\t\t//  yy   |        ║ - - - |\n\t\t//       |        ║\n\t\t//       |        ║       |\n\t\t//       |        ║              <-- support for a range of Y (at minX)\n\t\t//       |        ║       |\n\t\t//       |        ║  \n\t\t//  minY |        x - - - |\n\t\t//       |\n\t\t//       |-----------------------------\n\t\t//               minX    maxX\n\t\t//   \n\t\t\n\t\tboolean yySupport = ySupport && source.isYSupport(yy); // i.e. is source minX also minX at YY?\n\n\t\t//    y\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t// yy |         |-------|        |\n\t\t//    | a       |     b |        |\n\t\t//    |         |  b    |        |\n\t\t//    | a       |       |        |\n\t\t//    |     a   | b     |        |\n\t\t//    a---------b-------|        |\n\t\t//    |         |   c            |\n\t\t//    |         |     c          |\n\t\t//    |         |  c             |\n\t\t//    |         |      c         |\n\t\t//    |---------c----------------|--- x\n\t\t//\t\t               xx \n\t\t//\n\t\t// a - shadowed x\n\t\t// b - swallowed\n\t\t// c - shadowed y\n\t\t//\n\t\t// Copy maxX and maxY from existing points:\n\t\t// a & b used to determine maxX at yy\n\t\t// b & c used to determine maxY at xx\n\t\t\n\t\t// determine start and end index based on previous sort (in x direction)\n\t\t\n\t\tint pointIndex;\n\t\tif(yySupport) {\n\t\t\t// b and c only\n\t\t\tpointIndex = binarySearchMinusMinX(placement.getAbsoluteX());\n\t\t} else {\n\t\t\tpointIndex = 0;\n\t\t}\n\t\tint endIndex = binarySearchPlusMinX(placement.getAbsoluteEndX());\n\t\t\n\t\tnegativeMoveToXX.ensureCapacity(endIndex);\n\t\tnegativeMoveToYY.ensureCapacity(endIndex);\n\t\t\n\t\taddXX.ensureAdditionalCapacity(values.size());\n\t\taddYY.ensureAdditionalCapacity(values.size());\n\t\t\n\t\tfor(int i = pointIndex; i < endIndex; i++) {\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\n\t\t\tif(point.getMinY() > placement.getAbsoluteEndY()) {\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |  *           *        *\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          |      |     *\n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       *\n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz)\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |  *  *|\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\tif(point.getMinX() >= source.getMinX() && point.getMinY() >= source.getMinY()) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          | *  * |     \n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\n\t\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t\tnegativeMoveToXX.add(i);\n\t\t\t\t}\n\t\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t\tnegativeMoveToYY.add(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalues.flag(i);\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(xxSupport && yySupport) {\n\t\t\t\t// do not move points to xx, yy, or zz\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║------|\n\t\t\t\t// |   *      ║      |\n\t\t\t\t// |      *   ║══════════\n\t\t\t\t// |                       \n\t\t\t\t// |    *    *    *   \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t// \n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz), excluding the placement itself\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |      |\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\t// does any point intersect the xx, yy or zz planes?\n\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t// yz plane\n\t\t\t\tnegativeMoveToXX.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t// xz plane\n\t\t\t\tnegativeMoveToYY.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!negativeMoveToXX.isEmpty()) {\n\t\t\tnegativeMoveToXX.sortThis(COMPARATOR_MOVE_TO_XX);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < negativeMoveToXX.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(negativeMoveToXX.get(i));\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addXX.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addXX.get(k);\n\t\t\t\t\tif(add.eclipsesMovedX(p, xx)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// note: the new point might shadow one of the previous points\n\t\t\t\tPoint2D<P> moveX = p.moveX(xx, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddXX.add(moveX);\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(!negativeMoveToYY.isEmpty()) {\n\t\t\tnegativeMoveToYY.sortThis(COMPARATOR_MOVE_TO_YY);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < negativeMoveToYY.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(negativeMoveToYY.get(i));\n\t\t\t\t\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addYY.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addYY.get(k);\n\t\t\t\t\tif(add.eclipsesMovedY(p, yy)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPoint2D<P> moveY = p.moveY(yy, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddYY.add(moveY);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tif(xxSupport && yySupport) {\n\t\t\tfor (int i = pointIndex; i < endIndex; i++) {\n\t\t\t\tif(values.isFlag(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\tif(point.getMinY() < placement.getAbsoluteY() && withinX(point.getMinX(), placement)) {\n\t\t\t\t\tif(point.getMaxY() >= placement.getAbsoluteY()) {\n\t\t\t\t\t\tpoint.setMaxY(placement.getAbsoluteY() - 1);\n\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(point.getMinX() < placement.getAbsoluteX() && withinY(point.getMinY(), placement)) {\n\t\t\t\t\tif(point.getMaxX() >= placement.getAbsoluteX()) {\n\t\t\t\t\t\tpoint.setMaxX(placement.getAbsoluteX() - 1);\n\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconstrainFloatingMax(placement, endIndex);\t\t\t\n\t\t}\n\t\t\n\t\tendIndex -= values.removeFlagged();\n\t\t\n\t\tplacements.add(placement);\n\t\t\n\t\tint added = addXX.size() + addYY.size();\n\t\t// the new points have x coordinate between zero and xx. \n\t\t// insert them at the start of the existing data\n\t\t// so that the sorting algorithm does not have to do a full sort\n\t\t// rather only sort points with x coordinates from 0 to xx.\n\t\tvalues.ensureAdditionalCapacity(added);\n\t\t\n\t\t// insert xx last, because it has the highest x coordinate\n\t\tvalues.move(added);\n\t\tvalues.setAll(addYY, 0);\n\t\tvalues.setAll(addXX, addYY.size());\n\n\t\tremoveEclipsed(added);\n\t\t\n\t\tendIndex += added - values.removeFlagged();\n\n\t\t// make sure to capture all point <= xx\n\t\twhile(endIndex < values.size() && values.get(endIndex).getMinX() <= xx) {\n\t\t\tendIndex++;\n\t\t}\n\t\t\n\t\tvalues.sort(Point2D.COMPARATOR_X_THEN_Y, endIndex);\n\n\t\tnegativeMoveToXX.clear();\n\t\tnegativeMoveToYY.clear();\n\t\t\n\t\taddXX.clear();\n\t\taddYY.clear();\n\t\t\n\t\treturn !values.isEmpty();\n\t}\n","Method after Refactoring":"\tpublic boolean add(int index, P placement) {\n\t\t// overall approach:\n\t\t// Do not iterate over placements to find point max / mins, rather\n\t\t// project existing points. \n\t\t//  \n\t\t// project points swallowed by the placement, then delete them\n\t\t// project points shadowed by the placement to the other side\n\t\t// add points shadowed by the two new points (if they could be moved in the negative direction)\n\t\t// remove points which are eclipsed by others\n\t\t\n\t\t// keep track of placement borders, where possible\n\t\tPoint2D<P> source = values.get(index);\n\t\t\n\t\tboolean xSupport = source.isXSupport(source.getMinX());\n\t\tboolean ySupport = source.isYSupport(source.getMinY());\n\t\t\n\t\tint xx = placement.getAbsoluteEndX() + 1;\n\t\tint yy = placement.getAbsoluteEndY() + 1;\n\t\t\n\t\tvalues.flag(index);\n\t\t\n\t\t//       |\n\t\t//       |\n\t\t//       |        |---------------| \n\t\t//       |       \n\t\t//       |        |               |\n\t\t//       |    \n\t\t//  minY |        x════════════════         <---- support for a range of x (at minY)\n\t\t//       |                     \n\t\t//       |                    \n\t\t//       |--------------------------\n\t\t//               minX             maxX\n\t\t\n\t\tboolean xxSupport = xSupport && source.isXSupport(xx); // i.e. is source minY also minY at XX?\n\n\t\t//\n\t\t// vmaxY |                    \n\t\t//       |          \n\t\t//  yy   |        ║ - - - |\n\t\t//       |        ║\n\t\t//       |        ║       |\n\t\t//       |        ║              <-- support for a range of Y (at minX)\n\t\t//       |        ║       |\n\t\t//       |        ║  \n\t\t//  minY |        x - - - |\n\t\t//       |\n\t\t//       |-----------------------------\n\t\t//               minX    maxX\n\t\t//   \n\t\t\n\t\tboolean yySupport = ySupport && source.isYSupport(yy); // i.e. is source minX also minX at YY?\n\n\t\t//    y\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t// yy |         |-------|        |\n\t\t//    | a       |     b |        |\n\t\t//    |         |  b    |        |\n\t\t//    | a       |       |        |\n\t\t//    |     a   | b     |        |\n\t\t//    a---------b-------|        |\n\t\t//    |         |   c            |\n\t\t//    |         |     c          |\n\t\t//    |         |  c             |\n\t\t//    |         |      c         |\n\t\t//    |---------c----------------|--- x\n\t\t//\t\t               xx \n\t\t//\n\t\t// a - shadowed x\n\t\t// b - swallowed\n\t\t// c - shadowed y\n\t\t//\n\t\t// Copy maxX and maxY from existing points:\n\t\t// a & b used to determine maxX at yy\n\t\t// b & c used to determine maxY at xx\n\t\t\n\t\t// determine start and end index based on previous sort (in x direction)\n\t\t\n\t\tint pointIndex;\n\t\tif(yySupport) {\n\t\t\t// b and c only\n\t\t\t\n\t\t\t// already have index for point at absoluteX\n\t\t\tpointIndex = index;\n        \twhile(pointIndex > 0 && values.get(pointIndex - 1).getMinX() == placement.getAbsoluteX()) {\n        \t\tpointIndex--;\n        \t}\n\t\t} else {\n\t\t\tpointIndex = 0;\n\t\t}\n\t\tint endIndex = binarySearchPlusMinX(placement.getAbsoluteEndX());\n\t\t\n\t\tmoveToXX.ensureCapacity(endIndex);\n\t\tmoveToYY.ensureCapacity(endIndex);\n\t\t\n\t\taddXX.ensureAdditionalCapacity(values.size());\n\t\taddYY.ensureAdditionalCapacity(values.size());\n\t\t\n\t\tfor(int i = pointIndex; i < endIndex; i++) {\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\n\t\t\tif(point.getMinY() > placement.getAbsoluteEndY()) {\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |  *           *        *\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          |      |     *\n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       *\n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz)\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |  *  *|\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\tif(point.getMinX() >= source.getMinX() && point.getMinY() >= source.getMinY()) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          | *  * |     \n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\n\t\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t\tmoveToXX.add(i);\n\t\t\t\t}\n\t\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t\tmoveToYY.add(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalues.flag(i);\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(xxSupport && yySupport) {\n\t\t\t\t// do not move points to xx, yy, or zz\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║------|\n\t\t\t\t// |   *      ║      |\n\t\t\t\t// |      *   ║══════════\n\t\t\t\t// |                       \n\t\t\t\t// |    *    *    *   \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t// \n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz), excluding the placement itself\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |      |\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\t// does any point intersect the xx, yy or zz planes?\n\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t// yz plane\n\t\t\t\tmoveToXX.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t// xz plane\n\t\t\t\tmoveToYY.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!moveToXX.isEmpty()) {\n\t\t\tmoveToXX.sortThis(COMPARATOR_MOVE_TO_XX);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < moveToXX.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(moveToXX.get(i));\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addXX.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addXX.get(k);\n\t\t\t\t\tif(add.eclipsesMovedX(p, xx)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// note: the new point might shadow one of the previous points\n\t\t\t\tPoint2D<P> moveX = p.moveX(xx, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddXX.add(moveX);\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(!moveToYY.isEmpty()) {\n\t\t\tmoveToYY.sortThis(COMPARATOR_MOVE_TO_YY);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < moveToYY.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(moveToYY.get(i));\n\t\t\t\t\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addYY.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addYY.get(k);\n\t\t\t\t\tif(add.eclipsesMovedY(p, yy)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPoint2D<P> moveY = p.moveY(yy, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddYY.add(moveY);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tif(xxSupport && yySupport) {\n\t\t\t// no constrain necessary\n\t\t} else if(yySupport) {\n\t\t\t\n\t\t\t//\n\t\t\t// vmaxY |                    \n\t\t\t//       |          \n\t\t\t//  yy   |        ║ - - - |\n\t\t\t//       |        ║\n\t\t\t//       |        ║       |\n\t\t\t//       |        ║              \n\t\t\t//       |        ║       |\n\t\t\t//       |        ║  \n\t\t\t//  minY |        x - - - |\n\t\t\t//       |          *   *\n\t\t\t//       |        *   *\n\t\t\t//       |          *    *\n\t\t\t//       |-----------------------------\n\t\t\t//               minX    maxX\n\t\t\t//   \n\t\t\t// so only those points between 0 and minY \n\t\t\t// and between minX and maxX need to be constrained\n\t\t\t\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainMaxYWithClone(placement, pointIndex, endIndex);\n\t\t\t} else {\n\t\t\t\tconstrainMaxY(placement, pointIndex, endIndex);\n\t\t\t}\n\t\t} else if(xxSupport) {\n\t\t\t\n\t\t\t//       |\n\t\t\t//       |\n\t\t\t//       |     *  |---------------| \n\t\t\t//       | *     \n\t\t\t//       |    *   |               |\n\t\t\t//       |  * \n\t\t\t//  minY |    *   x════════════════        \n\t\t\t//       |                     \n\t\t\t//       |                    \n\t\t\t//       |--------------------------\n\t\t\t//               minX             maxX\n\t\t\t//\n\t\t\t// so only those points between 0 and minX \n\t\t\t// and between minY and maxY need to be constrained\n\t\t\t\n\t\t\tpointIndex = index;\n        \twhile(pointIndex > 0 && values.get(pointIndex - 1).getMinX() == placement.getAbsoluteX()) {\n        \t\tpointIndex--;\n        \t}\n\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainMaxXWithClone(placement, 0, pointIndex);\n\t\t\t} else {\n\t\t\t\tconstrainMaxX(placement, 0, pointIndex);\n\t\t\t}\n\t\t} else {\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainFloatingMaxWithClone(placement, endIndex);\n\t\t\t} else {\n\t\t\t\tconstrainFloatingMax(placement, endIndex);\n\t\t\t}\n\t\t}\n\t\t\n\t\tendIndex -= values.removeFlagged();\n\t\t\n\t\tplacements.add(placement);\n\t\t\n\t\tint added = addXX.size() + addYY.size();\n\t\t// the new points have x coordinate between zero and xx. \n\t\t// insert them at the start of the existing data\n\t\t// so that the sorting algorithm does not have to do a full sort\n\t\t// rather only sort points with x coordinates from 0 to xx.\n\t\tvalues.ensureAdditionalCapacity(added);\n\t\t\n\t\t// insert xx last, because it has the highest x coordinate\n\t\tvalues.move(added);\n\t\tvalues.setAll(addYY, 0);\n\t\tvalues.setAll(addXX, addYY.size());\n\n\t\tremoveEclipsed(added);\n\t\t\n\t\tendIndex += added - values.removeFlagged();\n\n\t\t// make sure to capture all point <= xx\n\t\twhile(endIndex < values.size() && values.get(endIndex).getMinX() <= xx) {\n\t\t\tendIndex++;\n\t\t}\n\t\t\n\t\tvalues.sort(Point2D.COMPARATOR_X_THEN_Y, endIndex);\n\n\t\tmoveToXX.clear();\n\t\tmoveToYY.clear();\n\t\t\n\t\taddXX.clear();\n\t\taddYY.clear();\n\t\t\n\t\treturn !values.isEmpty();\n\t}\n","Extracted Method":"\tprivate void constrainMaxX(P placement, int pointIndex, int endIndex) {\n\t\tfor (int i = pointIndex; i < endIndex; i++) {\n\t\t\tif(values.isFlag(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\tif(point.getMinX() < placement.getAbsoluteX() && withinY(point.getMinY(), placement)) {\n\t\t\t\tif(point.getMaxX() >= placement.getAbsoluteX()) {\n\t\t\t\t\tpoint.setMaxX(placement.getAbsoluteX() - 1);\n\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n"}
{"Smelly Sample":"\tpublic boolean add(int index, P placement) {\n\t\t// overall approach:\n\t\t// Do not iterate over placements to find point max / mins, rather\n\t\t// project existing points. \n\t\t//  \n\t\t// project points swallowed by the placement, then delete them\n\t\t// project points shadowed by the placement to the other side\n\t\t// add points shadowed by the two new points (if they could be moved in the negative direction)\n\t\t// remove points which are eclipsed by others\n\t\t\n\t\t// keep track of placement borders, where possible\n\t\tPoint2D<P> source = values.get(index);\n\t\t\n\t\tboolean xSupport = source.isXSupport(source.getMinX());\n\t\tboolean ySupport = source.isYSupport(source.getMinY());\n\t\t\n\t\tint xx = placement.getAbsoluteEndX() + 1;\n\t\tint yy = placement.getAbsoluteEndY() + 1;\n\t\t\n\t\tvalues.flag(index);\n\t\t\n\t\t//       |\n\t\t//       |\n\t\t//       |        |---------------| \n\t\t//       |       \n\t\t//       |        |               |\n\t\t//       |    \n\t\t//  minY |        x════════════════         <---- support for a range of x (at minY)\n\t\t//       |                     \n\t\t//       |                    \n\t\t//       |--------------------------\n\t\t//               minX             maxX\n\t\t\n\t\tboolean xxSupport = xSupport && source.isXSupport(xx); // i.e. is source minY also minY at XX?\n\n\t\t//\n\t\t// vmaxY |                    \n\t\t//       |          \n\t\t//  yy   |        ║ - - - |\n\t\t//       |        ║\n\t\t//       |        ║       |\n\t\t//       |        ║              <-- support for a range of Y (at minX)\n\t\t//       |        ║       |\n\t\t//       |        ║  \n\t\t//  minY |        x - - - |\n\t\t//       |\n\t\t//       |-----------------------------\n\t\t//               minX    maxX\n\t\t//   \n\t\t\n\t\tboolean yySupport = ySupport && source.isYSupport(yy); // i.e. is source minX also minX at YY?\n\n\t\t//    y\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t// yy |         |-------|        |\n\t\t//    | a       |     b |        |\n\t\t//    |         |  b    |        |\n\t\t//    | a       |       |        |\n\t\t//    |     a   | b     |        |\n\t\t//    a---------b-------|        |\n\t\t//    |         |   c            |\n\t\t//    |         |     c          |\n\t\t//    |         |  c             |\n\t\t//    |         |      c         |\n\t\t//    |---------c----------------|--- x\n\t\t//\t\t               xx \n\t\t//\n\t\t// a - shadowed x\n\t\t// b - swallowed\n\t\t// c - shadowed y\n\t\t//\n\t\t// Copy maxX and maxY from existing points:\n\t\t// a & b used to determine maxX at yy\n\t\t// b & c used to determine maxY at xx\n\t\t\n\t\t// determine start and end index based on previous sort (in x direction)\n\t\t\n\t\tint pointIndex;\n\t\tif(yySupport) {\n\t\t\t// b and c only\n\t\t\tpointIndex = binarySearchMinusMinX(placement.getAbsoluteX());\n\t\t} else {\n\t\t\tpointIndex = 0;\n\t\t}\n\t\tint endIndex = binarySearchPlusMinX(placement.getAbsoluteEndX());\n\t\t\n\t\tnegativeMoveToXX.ensureCapacity(endIndex);\n\t\tnegativeMoveToYY.ensureCapacity(endIndex);\n\t\t\n\t\taddXX.ensureAdditionalCapacity(values.size());\n\t\taddYY.ensureAdditionalCapacity(values.size());\n\t\t\n\t\tfor(int i = pointIndex; i < endIndex; i++) {\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\n\t\t\tif(point.getMinY() > placement.getAbsoluteEndY()) {\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |  *           *        *\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          |      |     *\n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       *\n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz)\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |  *  *|\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\tif(point.getMinX() >= source.getMinX() && point.getMinY() >= source.getMinY()) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          | *  * |     \n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\n\t\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t\tnegativeMoveToXX.add(i);\n\t\t\t\t}\n\t\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t\tnegativeMoveToYY.add(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalues.flag(i);\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(xxSupport && yySupport) {\n\t\t\t\t// do not move points to xx, yy, or zz\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║------|\n\t\t\t\t// |   *      ║      |\n\t\t\t\t// |      *   ║══════════\n\t\t\t\t// |                       \n\t\t\t\t// |    *    *    *   \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t// \n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz), excluding the placement itself\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |      |\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\t// does any point intersect the xx, yy or zz planes?\n\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t// yz plane\n\t\t\t\tnegativeMoveToXX.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t// xz plane\n\t\t\t\tnegativeMoveToYY.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!negativeMoveToXX.isEmpty()) {\n\t\t\tnegativeMoveToXX.sortThis(COMPARATOR_MOVE_TO_XX);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < negativeMoveToXX.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(negativeMoveToXX.get(i));\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addXX.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addXX.get(k);\n\t\t\t\t\tif(add.eclipsesMovedX(p, xx)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// note: the new point might shadow one of the previous points\n\t\t\t\tPoint2D<P> moveX = p.moveX(xx, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddXX.add(moveX);\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(!negativeMoveToYY.isEmpty()) {\n\t\t\tnegativeMoveToYY.sortThis(COMPARATOR_MOVE_TO_YY);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < negativeMoveToYY.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(negativeMoveToYY.get(i));\n\t\t\t\t\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addYY.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addYY.get(k);\n\t\t\t\t\tif(add.eclipsesMovedY(p, yy)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPoint2D<P> moveY = p.moveY(yy, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddYY.add(moveY);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tif(xxSupport && yySupport) {\n\t\t\tfor (int i = pointIndex; i < endIndex; i++) {\n\t\t\t\tif(values.isFlag(i)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\tif(point.getMinY() < placement.getAbsoluteY() && withinX(point.getMinX(), placement)) {\n\t\t\t\t\tif(point.getMaxY() >= placement.getAbsoluteY()) {\n\t\t\t\t\t\tpoint.setMaxY(placement.getAbsoluteY() - 1);\n\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(point.getMinX() < placement.getAbsoluteX() && withinY(point.getMinY(), placement)) {\n\t\t\t\t\tif(point.getMaxX() >= placement.getAbsoluteX()) {\n\t\t\t\t\t\tpoint.setMaxX(placement.getAbsoluteX() - 1);\n\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconstrainFloatingMax(placement, endIndex);\t\t\t\n\t\t}\n\t\t\n\t\tendIndex -= values.removeFlagged();\n\t\t\n\t\tplacements.add(placement);\n\t\t\n\t\tint added = addXX.size() + addYY.size();\n\t\t// the new points have x coordinate between zero and xx. \n\t\t// insert them at the start of the existing data\n\t\t// so that the sorting algorithm does not have to do a full sort\n\t\t// rather only sort points with x coordinates from 0 to xx.\n\t\tvalues.ensureAdditionalCapacity(added);\n\t\t\n\t\t// insert xx last, because it has the highest x coordinate\n\t\tvalues.move(added);\n\t\tvalues.setAll(addYY, 0);\n\t\tvalues.setAll(addXX, addYY.size());\n\n\t\tremoveEclipsed(added);\n\t\t\n\t\tendIndex += added - values.removeFlagged();\n\n\t\t// make sure to capture all point <= xx\n\t\twhile(endIndex < values.size() && values.get(endIndex).getMinX() <= xx) {\n\t\t\tendIndex++;\n\t\t}\n\t\t\n\t\tvalues.sort(Point2D.COMPARATOR_X_THEN_Y, endIndex);\n\n\t\tnegativeMoveToXX.clear();\n\t\tnegativeMoveToYY.clear();\n\t\t\n\t\taddXX.clear();\n\t\taddYY.clear();\n\t\t\n\t\treturn !values.isEmpty();\n\t}\n","Method after Refactoring":"\tpublic boolean add(int index, P placement) {\n\t\t// overall approach:\n\t\t// Do not iterate over placements to find point max / mins, rather\n\t\t// project existing points. \n\t\t//  \n\t\t// project points swallowed by the placement, then delete them\n\t\t// project points shadowed by the placement to the other side\n\t\t// add points shadowed by the two new points (if they could be moved in the negative direction)\n\t\t// remove points which are eclipsed by others\n\t\t\n\t\t// keep track of placement borders, where possible\n\t\tPoint2D<P> source = values.get(index);\n\t\t\n\t\tboolean xSupport = source.isXSupport(source.getMinX());\n\t\tboolean ySupport = source.isYSupport(source.getMinY());\n\t\t\n\t\tint xx = placement.getAbsoluteEndX() + 1;\n\t\tint yy = placement.getAbsoluteEndY() + 1;\n\t\t\n\t\tvalues.flag(index);\n\t\t\n\t\t//       |\n\t\t//       |\n\t\t//       |        |---------------| \n\t\t//       |       \n\t\t//       |        |               |\n\t\t//       |    \n\t\t//  minY |        x════════════════         <---- support for a range of x (at minY)\n\t\t//       |                     \n\t\t//       |                    \n\t\t//       |--------------------------\n\t\t//               minX             maxX\n\t\t\n\t\tboolean xxSupport = xSupport && source.isXSupport(xx); // i.e. is source minY also minY at XX?\n\n\t\t//\n\t\t// vmaxY |                    \n\t\t//       |          \n\t\t//  yy   |        ║ - - - |\n\t\t//       |        ║\n\t\t//       |        ║       |\n\t\t//       |        ║              <-- support for a range of Y (at minX)\n\t\t//       |        ║       |\n\t\t//       |        ║  \n\t\t//  minY |        x - - - |\n\t\t//       |\n\t\t//       |-----------------------------\n\t\t//               minX    maxX\n\t\t//   \n\t\t\n\t\tboolean yySupport = ySupport && source.isYSupport(yy); // i.e. is source minX also minX at YY?\n\n\t\t//    y\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t//    |                          |\n\t\t// yy |         |-------|        |\n\t\t//    | a       |     b |        |\n\t\t//    |         |  b    |        |\n\t\t//    | a       |       |        |\n\t\t//    |     a   | b     |        |\n\t\t//    a---------b-------|        |\n\t\t//    |         |   c            |\n\t\t//    |         |     c          |\n\t\t//    |         |  c             |\n\t\t//    |         |      c         |\n\t\t//    |---------c----------------|--- x\n\t\t//\t\t               xx \n\t\t//\n\t\t// a - shadowed x\n\t\t// b - swallowed\n\t\t// c - shadowed y\n\t\t//\n\t\t// Copy maxX and maxY from existing points:\n\t\t// a & b used to determine maxX at yy\n\t\t// b & c used to determine maxY at xx\n\t\t\n\t\t// determine start and end index based on previous sort (in x direction)\n\t\t\n\t\tint pointIndex;\n\t\tif(yySupport) {\n\t\t\t// b and c only\n\t\t\t\n\t\t\t// already have index for point at absoluteX\n\t\t\tpointIndex = index;\n        \twhile(pointIndex > 0 && values.get(pointIndex - 1).getMinX() == placement.getAbsoluteX()) {\n        \t\tpointIndex--;\n        \t}\n\t\t} else {\n\t\t\tpointIndex = 0;\n\t\t}\n\t\tint endIndex = binarySearchPlusMinX(placement.getAbsoluteEndX());\n\t\t\n\t\tmoveToXX.ensureCapacity(endIndex);\n\t\tmoveToYY.ensureCapacity(endIndex);\n\t\t\n\t\taddXX.ensureAdditionalCapacity(values.size());\n\t\taddYY.ensureAdditionalCapacity(values.size());\n\t\t\n\t\tfor(int i = pointIndex; i < endIndex; i++) {\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\t\n\t\t\tif(point.getMinY() > placement.getAbsoluteEndY()) {\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |  *           *        *\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          |      |     *\n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       *\n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz)\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |  *  *|\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\tif(point.getMinX() >= source.getMinX() && point.getMinY() >= source.getMinY()) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |\n\t\t\t\t// |          \n\t\t\t\t// |          |------|\n\t\t\t\t// |          | *  * |     \n\t\t\t\t// |          |------|\n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t//\n\n\t\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t\tmoveToXX.add(i);\n\t\t\t\t}\n\t\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t\tmoveToYY.add(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalues.flag(i);\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(xxSupport && yySupport) {\n\t\t\t\t// do not move points to xx, yy, or zz\n\t\t\t\t// \n\t\t\t\t// |\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║\n\t\t\t\t// |          ║------|\n\t\t\t\t// |   *      ║      |\n\t\t\t\t// |      *   ║══════════\n\t\t\t\t// |                       \n\t\t\t\t// |    *    *    *   \n\t\t\t\t// |                       \n\t\t\t\t// ---------------------------\n\t\t\t\t// \n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Points within (xx, yy, zz), excluding the placement itself\n\t\t\t// \n\t\t\t// |\n\t\t\t// |\n\t\t\t// |          \n\t\t\t// | *  *     |------|\n\t\t\t// |          |      |\n\t\t\t// |   *      |------|\n\t\t\t// |              *        \n\t\t\t// |     *   *       *\n\t\t\t// | *         *            \n\t\t\t// ---------------------------\n\t\t\t//\n\n\t\t\t// does any point intersect the xx, yy or zz planes?\n\t\t\tif(canMoveX(point, xx)) {\n\t\t\t\t// yz plane\n\t\t\t\tmoveToXX.add(i);\n\t\t\t}\n\t\t\t\n\t\t\tif(canMoveY(point, yy)) {\n\t\t\t\t// xz plane\n\t\t\t\tmoveToYY.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!moveToXX.isEmpty()) {\n\t\t\tmoveToXX.sortThis(COMPARATOR_MOVE_TO_XX);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < moveToXX.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(moveToXX.get(i));\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addXX.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addXX.get(k);\n\t\t\t\t\tif(add.eclipsesMovedX(p, xx)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// note: the new point might shadow one of the previous points\n\t\t\t\tPoint2D<P> moveX = p.moveX(xx, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddXX.add(moveX);\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tif(!moveToYY.isEmpty()) {\n\t\t\tmoveToYY.sortThis(COMPARATOR_MOVE_TO_YY);\n\t\t\t\n\t\t\tadd:\n\t\t\tfor(int i = 0; i < moveToYY.size(); i++) {\n\t\t\t\tPoint2D<P> p = values.get(moveToYY.get(i));\n\t\t\t\t\n\t\t\t\t// add point on the other side\n\t\t\t\t// with x support\n\t\t\t\tfor(int k = 0; k < addYY.size(); k++) {\n\t\t\t\t\tPoint2D<P> add = addYY.get(k);\n\t\t\t\t\tif(add.eclipsesMovedY(p, yy)) {\n\t\t\t\t\t\tcontinue add;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPoint2D<P> moveY = p.moveY(yy, p.getMaxX(), p.getMaxY(), placement);\n\t\t\t\taddYY.add(moveY);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\tif(xxSupport && yySupport) {\n\t\t\t// no constrain necessary\n\t\t} else if(yySupport) {\n\t\t\t\n\t\t\t//\n\t\t\t// vmaxY |                    \n\t\t\t//       |          \n\t\t\t//  yy   |        ║ - - - |\n\t\t\t//       |        ║\n\t\t\t//       |        ║       |\n\t\t\t//       |        ║              \n\t\t\t//       |        ║       |\n\t\t\t//       |        ║  \n\t\t\t//  minY |        x - - - |\n\t\t\t//       |          *   *\n\t\t\t//       |        *   *\n\t\t\t//       |          *    *\n\t\t\t//       |-----------------------------\n\t\t\t//               minX    maxX\n\t\t\t//   \n\t\t\t// so only those points between 0 and minY \n\t\t\t// and between minX and maxX need to be constrained\n\t\t\t\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainMaxYWithClone(placement, pointIndex, endIndex);\n\t\t\t} else {\n\t\t\t\tconstrainMaxY(placement, pointIndex, endIndex);\n\t\t\t}\n\t\t} else if(xxSupport) {\n\t\t\t\n\t\t\t//       |\n\t\t\t//       |\n\t\t\t//       |     *  |---------------| \n\t\t\t//       | *     \n\t\t\t//       |    *   |               |\n\t\t\t//       |  * \n\t\t\t//  minY |    *   x════════════════        \n\t\t\t//       |                     \n\t\t\t//       |                    \n\t\t\t//       |--------------------------\n\t\t\t//               minX             maxX\n\t\t\t//\n\t\t\t// so only those points between 0 and minX \n\t\t\t// and between minY and maxY need to be constrained\n\t\t\t\n\t\t\tpointIndex = index;\n        \twhile(pointIndex > 0 && values.get(pointIndex - 1).getMinX() == placement.getAbsoluteX()) {\n        \t\tpointIndex--;\n        \t}\n\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainMaxXWithClone(placement, 0, pointIndex);\n\t\t\t} else {\n\t\t\t\tconstrainMaxX(placement, 0, pointIndex);\n\t\t\t}\n\t\t} else {\n\t\t\tif(cloneOnConstrain) {\n\t\t\t\tconstrainFloatingMaxWithClone(placement, endIndex);\n\t\t\t} else {\n\t\t\t\tconstrainFloatingMax(placement, endIndex);\n\t\t\t}\n\t\t}\n\t\t\n\t\tendIndex -= values.removeFlagged();\n\t\t\n\t\tplacements.add(placement);\n\t\t\n\t\tint added = addXX.size() + addYY.size();\n\t\t// the new points have x coordinate between zero and xx. \n\t\t// insert them at the start of the existing data\n\t\t// so that the sorting algorithm does not have to do a full sort\n\t\t// rather only sort points with x coordinates from 0 to xx.\n\t\tvalues.ensureAdditionalCapacity(added);\n\t\t\n\t\t// insert xx last, because it has the highest x coordinate\n\t\tvalues.move(added);\n\t\tvalues.setAll(addYY, 0);\n\t\tvalues.setAll(addXX, addYY.size());\n\n\t\tremoveEclipsed(added);\n\t\t\n\t\tendIndex += added - values.removeFlagged();\n\n\t\t// make sure to capture all point <= xx\n\t\twhile(endIndex < values.size() && values.get(endIndex).getMinX() <= xx) {\n\t\t\tendIndex++;\n\t\t}\n\t\t\n\t\tvalues.sort(Point2D.COMPARATOR_X_THEN_Y, endIndex);\n\n\t\tmoveToXX.clear();\n\t\tmoveToYY.clear();\n\t\t\n\t\taddXX.clear();\n\t\taddYY.clear();\n\t\t\n\t\treturn !values.isEmpty();\n\t}\n","Extracted Method":"\tprivate void constrainMaxY(P placement, int pointIndex, int endIndex) {\n\t\tfor (int i = pointIndex; i < endIndex; i++) {\n\t\t\tif(values.isFlag(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D<P> point = values.get(i);\n\t\t\tif(point.getMinY() < placement.getAbsoluteY() && withinX(point.getMinX(), placement)) {\n\t\t\t\tif(point.getMaxY() >= placement.getAbsoluteY()) {\n\t\t\t\t\tpoint.setMaxY(placement.getAbsoluteY() - 1);\n\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n"}
{"Smelly Sample":"\tprotected void constrainFloatingMax(P placement, int limit) {\n\n\t\taddXX.ensureAdditionalCapacity(limit);\n\t\taddYY.ensureAdditionalCapacity(limit);\n\t\taddZZ.ensureAdditionalCapacity(limit);\n\t\t\n\t\tfor (int i = 0; i < limit; i++) {\n\t\t\tPoint3D<P> point = values.get(i);\n\t\t\t\n\t\t\tif(placement.getAbsoluteEndX() < point.getMinX()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(placement.getAbsoluteEndY() < point.getMinY()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(placement.getAbsoluteEndZ() < point.getMinZ()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(placement.getAbsoluteX() > point.getMaxX()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(placement.getAbsoluteY() > point.getMaxY()) {\n\t\t\t\tcontinue;\n\t\t\t}\t\n\n\t\t\tif(placement.getAbsoluteZ() > point.getMaxZ()) {\n\t\t\t\tcontinue;\n\t\t\t}\t\n\n\t\t\tboolean x = placement.getAbsoluteX() <= point.getMaxX();\n\t\t\tboolean y = placement.getAbsoluteY() <= point.getMaxY();\n\t\t\tboolean z = placement.getAbsoluteZ() <= point.getMaxZ();\n\n\t\t\tboolean constrain = x && y && z;\n\t\t\tif(!constrain) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(!cloneOnConstrain) {\n\t\t\t\tif(point.getMinY() >= placement.getAbsoluteY() && point.getMinZ() >= placement.getAbsoluteZ() ) {\n\t\t\t\t\t// adjusting x is sufficient\n\t\t\t\t\tif(point.getMinX() < placement.getAbsoluteX()) {\n\t\t\t\t\t\tpoint.setMaxX(placement.getAbsoluteX() - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(point.getVolume() < minVolumeLimit || point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// is the point now eclipsed?\n\t\t\t\t\t\tfor (int j = 0; j < i - 1; j++) {\n\t\t\t\t\t\t\tPoint3D<P> point3d = values.get(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(point3d.eclipses(point)) {\n\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(point.getMinX() >= placement.getAbsoluteX() && point.getMinZ() >= placement.getAbsoluteZ() ) {\n\t\t\t\t\t// adjusting y is sufficient\n\t\t\t\t\tif(point.getMinY() < placement.getAbsoluteY()) {\n\t\t\t\t\t\tpoint.setMaxY(placement.getAbsoluteY() - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(point.getVolume() < minVolumeLimit || point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// is the point now eclipsed?\n\t\t\t\t\t\tfor (int j = 0; j < i - 1; j++) {\n\t\t\t\t\t\t\tPoint3D<P> point3d = values.get(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(point3d.eclipses(point)) {\n\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(point.getMinY() >= placement.getAbsoluteY() && point.getMinX() >= placement.getAbsoluteX() ) {\n\t\t\t\t\t// adjusting z is sufficient\n\t\t\t\t\tif(point.getMinZ() < placement.getAbsoluteZ()) {\n\t\t\t\t\t\tpoint.setMaxZ(placement.getAbsoluteZ() - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(point.getVolume() < minVolumeLimit || point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// is the point now eclipsed?\n\t\t\t\t\t\tfor (int j = 0; j < i - 1; j++) {\n\t\t\t\t\t\t\tPoint3D<P> point3d = values.get(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(point3d.eclipses(point)) {\n\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// fall through: must add multiple points\n\t\t\t}\n\t\t\t\n\t\t\tif(x) {\n\t\t\t\tif(point.getMinX() < placement.getAbsoluteX()) {\n\t\t\t\t\tif(!isConstrainedAtMaxX(point, placement.getAbsoluteX() - 1)) {\n\t\t\t\t\t\taddXX.add(point.clone(placement.getAbsoluteX() - 1, point.getMaxY(), point.getMaxZ()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(y) {\n\t\t\t\tif(point.getMinY() < placement.getAbsoluteY()) {\n\t\t\t\t\tif(!isConstrainedAtMaxY(point, placement.getAbsoluteY() - 1)) {\n\t\t\t\t\t\taddYY.add(point.clone(point.getMaxX(), placement.getAbsoluteY() - 1, point.getMaxZ()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(z) {\n\t\t\t\tif(point.getMinZ() < placement.getAbsoluteZ()) {\n\t\t\t\t\tif(!isConstrainedAtMaxZ(point, placement.getAbsoluteZ() - 1)) {\n\t\t\t\t\t\taddZZ.add(point.clone(point.getMaxX(), point.getMaxY(), placement.getAbsoluteZ() - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalues.flag(i);\n\t\t}\n\t\t\n\t}\t\n","Method after Refactoring":"\tprotected void constrainFloatingMax(P placement, int limit) {\n\n\t\tPoint3DFlagList<P> values = this.values;\n\t\tPoint3DList<P> addXX = this.addXX;\n\t\tPoint3DList<P> addYY = this.addYY;\n\t\tPoint3DList<P> addZZ = this.addZZ;\n\t\t\n\t\tlong minAreaLimit = this.minAreaLimit;\n\t\tlong minVolumeLimit = this.minVolumeLimit;\n\t\t\n\t\taddXX.ensureAdditionalCapacity(limit);\n\t\taddYY.ensureAdditionalCapacity(limit);\n\t\taddZZ.ensureAdditionalCapacity(limit);\n\t\t\n\t\tint startAddXX = addXX.size();\n\t\tint startAddYY = addYY.size();\n\t\tint startAddZZ = addZZ.size();\n\t\t\n\t\tboolean splitXX = false;\n\t\tboolean splitYY = false;\n\t\tboolean splitZZ = false;\n\n\t\tlimitLoop:\n\t\tfor (int i = 0; i < limit; i++) {\n\t\t\tPoint3D<P> point = values.get(i);\n\n\t\t\tif(\n\t\t\t\t\tplacement.getAbsoluteEndZ() < point.getMinZ() ||\n\t\t\t\t\tplacement.getAbsoluteEndY() < point.getMinY() ||\n\t\t\t\t\tplacement.getAbsoluteEndX() < point.getMinX() ||\n\t\t\t\t\tplacement.getAbsoluteX() > point.getMaxX() || \n\t\t\t\t\tplacement.getAbsoluteY() > point.getMaxY() ||\n\t\t\t\t\tplacement.getAbsoluteZ() > point.getMaxZ()\n\t\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(point.getMinY() >= placement.getAbsoluteY() && point.getMinZ() >= placement.getAbsoluteZ() ) {\n\t\t\t\t// adjusting x is sufficient\n\t\t\t\tif(point.getMinX() < placement.getAbsoluteX()) {\n\t\t\t\t\tpoint.setMaxX(placement.getAbsoluteX() - 1);\n\t\t\t\t\t\n\t\t\t\t\tif(point.getVolume() < minVolumeLimit || point.getArea() < minAreaLimit) {\n\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// is the point now eclipsed by current points?\n\t\t\t\t\tfor (int j = 0; j < i - 1; j++) {\n\t\t\t\t\t\tPoint3D<P> point3d = values.get(j);\n\t\t\t\t\t\tif(point3d.getMinX() > point.getMinX()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(point3d.getVolume() >= point.getVolume()) {\n\t\t\t\t\t\t\tif(point3d.eclipses(point)) {\n\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcontinue limitLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(splitXX) {\n\t\t\t\t\t\t// is the point now eclipsed by new points?\n\t\t\t\t\t\tfor (int j = startAddXX; j < addXX.size(); j++) {\n\t\t\t\t\t\t\tPoint3D<P> point3d = addXX.get(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(point3d.getVolume() >= point.getVolume()) {\n\t\t\t\t\t\t\t\tif(point3d.eclipses(point)) {\n\t\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tvalues.flag(i);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(point.getMinX() >= placement.getAbsoluteX() && point.getMinZ() >= placement.getAbsoluteZ() ) {\n\t\t\t\t// adjusting y is sufficient\n\t\t\t\tif(point.getMinY() < placement.getAbsoluteY()) {\n\t\t\t\t\tpoint.setMaxY(placement.getAbsoluteY() - 1);\n\t\t\t\t\t\n\t\t\t\t\tif(point.getVolume() < minVolumeLimit || point.getArea() < minAreaLimit) {\n\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// is the point now eclipsed by current points?\n\t\t\t\t\tfor (int j = 0; j < i - 1; j++) {\n\t\t\t\t\t\tPoint3D<P> point3d = values.get(j);\n\t\t\t\t\t\tif(point3d.getMinX() > point.getMinX()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(point3d.getVolume() >= point.getVolume()) {\n\t\t\t\t\t\t\tif(point3d.eclipses(point)) {\n\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcontinue limitLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(splitYY) {\n\t\t\t\t\t\t// is the point now eclipsed by new points?\n\t\t\t\t\t\tfor (int j = startAddYY; j < addYY.size(); j++) {\n\t\t\t\t\t\t\tPoint3D<P> point3d = addYY.get(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(point3d.getVolume() >= point.getVolume()) {\n\t\t\t\t\t\t\t\tif(point3d.eclipses(point)) {\n\t\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tvalues.flag(i);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(point.getMinY() >= placement.getAbsoluteY() && point.getMinX() >= placement.getAbsoluteX() ) {\n\t\t\t\t// adjusting z is sufficient\n\t\t\t\tif(point.getMinZ() < placement.getAbsoluteZ()) {\n\t\t\t\t\tpoint.setMaxZ(placement.getAbsoluteZ() - 1);\n\t\t\t\t\t\n\t\t\t\t\tif(point.getVolume() < minVolumeLimit || point.getArea() < minAreaLimit) {\n\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// is the point now eclipsed by current points?\n\t\t\t\t\tfor (int j = 0; j < i - 1; j++) {\n\t\t\t\t\t\tPoint3D<P> point3d = values.get(j);\n\t\t\t\t\t\tif(point3d.getMinX() > point.getMinX()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(point3d.getVolume() >= point.getVolume()) {\n\t\t\t\t\t\t\tif(point3d.eclipses(point)) {\n\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcontinue limitLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(splitZZ) {\n\t\t\t\t\t\t// is the point now eclipsed by new points?\n\t\t\t\t\t\tfor (int j = startAddZZ; j < addZZ.size(); j++) {\n\t\t\t\t\t\t\tPoint3D<P> point3d = addZZ.get(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(point3d.getVolume() >= point.getVolume()) {\n\t\t\t\t\t\t\t\tif(point3d.eclipses(point)) {\n\t\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tvalues.flag(i);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// fall through: must add multiple points\n\t\t\t\n\t\t\t// Points eclipsed by others:\n\t\t\t// before add\n\t\t\t//    \n\t\t\t//    |\n\t\t\t//    |--------|\n\t\t\t//    |        |\n\t\t\t//    |--------| \n\t\t\t//    |\n\t\t\t//    |\n\t\t\t//    |\n\t\t\t// a  *        *      |---------|\n\t\t\t//    |               |         |\n\t\t\t//    |               |         |\n\t\t\t//    *--------*------|---------|-----\n\t\t\t//    c        b\n\n\t\t\t//  after add\n\t\t\t//             \n\t\t\t//    |        |---------|\n\t\t\t//    |--------|         | \n\t\t\t//    |        |         |\n\t\t\t//    |--------|         |\n\t\t\t//    |        |         |\n\t\t\t//    |        |         |\n\t\t\t// a  *        |------|--|------|\n\t\t\t//    |               |         |\n\t\t\t//    |               |         |\n\t\t\t//    *--------*------|---------|-----\n\t\t\t//    c        b\n\t\t\t\n\t\t\t//\n\t\t\t// Point c is split in two, each of which eclipse a or b\n\t\t\t//\n\t\t\t// So that we end up with\n\t\t\t//             \n\t\t\t//    |        |---------|\n\t\t\t//    |--------|         | \n\t\t\t//    |        |         |\n\t\t\t//    |--------|         |\n\t\t\t//    |        |         |\n\t\t\t//    |        |         |\n\t\t\t//    |        |------|--|------|\n\t\t\t//    |               |         |\n\t\t\t//    |               |         |\n\t\t\t//    *---------------|---------|-----\n\t\t\t//    c         \n\t\t\t\n\t\t\t\n\t\t\tif(!isConstrainedAtMaxX(point, placement.getAbsoluteX() - 1)) {\n\t\t\t\taddXX.add(point.clone(placement.getAbsoluteX() - 1, point.getMaxY(), point.getMaxZ()));\n\t\t\t\t\n\t\t\t\tsplitXX = true;\n\t\t\t}\n\t\t\tif(!isConstrainedAtMaxY(point, placement.getAbsoluteY() - 1)) {\n\t\t\t\taddYY.add(point.clone(point.getMaxX(), placement.getAbsoluteY() - 1, point.getMaxZ()));\n\t\t\t\tsplitYY = true;\n\t\t\t}\n\t\t\t\n\t\t\tif(!isConstrainedAtMaxZ(point, placement.getAbsoluteZ() - 1)) {\n\t\t\t\taddZZ.add(point.clone(point.getMaxX(), point.getMaxY(), placement.getAbsoluteZ() - 1));\n\t\t\t\t\n\t\t\t\tsplitZZ = true;\n\t\t\t}\n\t\t\tvalues.flag(i);\n\t\t}\n\t\t\n\t}\n","Extracted Method":"\tprivate void constrainMax(P placement, int endIndex) {\n\t\tfor (int i = 0; i < endIndex; i++) {\n\t\t\tif(values.isFlag(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tPoint3D<P> point = values.get(i);\n\t\t\tif(!withinX(point.getMinX(), placement)) {\n\t\t\t\tif(withinZ(point.getMinZ(), placement) && withinY(point.getMinY(), placement)) {\n\t\t\t\t\tif(point.getMinX() < placement.getAbsoluteX()) {\n\t\t\t\t\t\tif(point.getMaxX() >= placement.getAbsoluteX()) {\n\t\t\t\t\t\t\tpoint.setMaxX(placement.getAbsoluteX() - 1);\n\t\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t} else if(!withinY(point.getMinY(), placement)) {\n\t\t\t\t// already within x\n\t\t\t\tif(withinZ(point.getMinZ(), placement)) {\n\t\t\t\t\tif(point.getMinY() < placement.getAbsoluteY()) {\n\t\t\t\t\t\tif(point.getMaxY() >= placement.getAbsoluteY()) {\n\t\t\t\t\t\t\tpoint.setMaxY(placement.getAbsoluteY() - 1);\n\t\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(point.getMinZ() < placement.getAbsoluteZ()) { // i.e. not within z\n\t\t\t\t// already within x and y\n\t\t\t\tif(point.getMaxZ() >= placement.getAbsoluteZ()) {\n\t\t\t\t\tif(point.getMaxZ() >= placement.getAbsoluteZ()) {\n\t\t\t\t\t\tpoint.setMaxZ(placement.getAbsoluteZ() - 1);\n\t\t\t\t\t\tif(point.getArea() < minAreaLimit) {\n\t\t\t\t\t\t\tvalues.flag(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\t\t\t\n\t\t}\n\t}\n"}
{"Smelly Sample":"\tpublic ExtremePoints2D(int dx, int dy) {\n\t\tsetSize(dx, dy);\n\t\taddFirstPoint();\n\t}\n","Method after Refactoring":"\tpublic ExtremePoints2D(int dx, int dy) {\n\t\tthis(dx, dy, false);\n\t}\n","Extracted Method":"\tpublic ExtremePoints2D(int dx, int dy, boolean cloneOnConstrain) {\n\t\tsetSize(dx, dy);\n\t\tthis.cloneOnConstrain = cloneOnConstrain;\n\t\taddFirstPoint();\n\t}\n"}
{"Smelly Sample":"\tprivate boolean canMoveX(Point3D<P> p, int xx) {\n\t\tlong areaAtX = p.getAreaAtX(xx);\n\t\tif(areaAtX < minAreaLimit) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areaAtX * p.getDz() >= minVolumeLimit;\n\t}\n","Method after Refactoring":"\tprivate boolean canMoveX(Point3D<P> p, int xx) {\n\t\tif(p.getMaxX() < xx) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !isConstrainedAtX(p, xx);\n\t}\n","Extracted Method":"\tprivate boolean isConstrainedAtX(Point3D<P> p, int xx) {\n\t\tlong areaAtX = p.getAreaAtX(xx);\n\t\tif(areaAtX >= minAreaLimit) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areaAtX * p.getDz() < minVolumeLimit;\n\t}\n"}
{"Smelly Sample":"\tprivate boolean canMoveY(Point3D<P> p, int yy) {\n\t\tlong areaAtY = p.getAreaAtY(yy);\n\t\tif(areaAtY < minAreaLimit) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areaAtY * p.getDz() >= minVolumeLimit;\n\t}\n","Method after Refactoring":"\tprivate boolean canMoveY(Point3D<P> p, int yy) {\n\t\tif(p.getMaxY() < yy) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !isConstraintedAtY(p, yy);\n\t}\n","Extracted Method":"\tprivate boolean isConstraintedAtY(Point3D<P> p, int yy) {\n\t\tlong areaAtY = p.getAreaAtY(yy);\n\t\tif(areaAtY >= minAreaLimit) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areaAtY * p.getDz() < minVolumeLimit;\n\t}\n"}
{"Smelly Sample":"\tprivate boolean canMoveX(Point3D<P> p, int xx) {\n\t\tlong areaAtX = p.getAreaAtX(xx);\n\t\tif(areaAtX < minAreaLimit) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areaAtX * p.getDz() >= minVolumeLimit;\n\t}\n","Method after Refactoring":"\tprivate boolean canMoveX(Point3D<P> p, int xx) {\n\t\tif(p.getMaxX() < xx) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !isConstrainedAtX(p, xx);\n\t}\n","Extracted Method":"\tprivate boolean isConstrainedAtX(Point3D<P> p, int xx) {\n\t\tlong areaAtX = p.getAreaAtX(xx);\n\t\tif(areaAtX >= minAreaLimit) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areaAtX * p.getDz() < minVolumeLimit;\n\t}\n"}
{"Smelly Sample":"\tprivate boolean canMoveY(Point3D<P> p, int yy) {\n\t\tlong areaAtY = p.getAreaAtY(yy);\n\t\tif(areaAtY < minAreaLimit) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areaAtY * p.getDz() >= minVolumeLimit;\n\t}\n","Method after Refactoring":"\tprivate boolean canMoveY(Point3D<P> p, int yy) {\n\t\tif(p.getMaxY() < yy) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !isConstraintedAtY(p, yy);\n\t}\n","Extracted Method":"\tprivate boolean isConstraintedAtY(Point3D<P> p, int yy) {\n\t\tlong areaAtY = p.getAreaAtY(yy);\n\t\tif(areaAtY >= minAreaLimit) {\n\t\t\treturn false;\n\t\t}\n\t\treturn areaAtY * p.getDz() < minVolumeLimit;\n\t}\n"}
{"Smelly Sample":"\t@Test\n\tpublic void testPackager() throws Exception {\n\t\t\n\t\t// issue 159\n\t\tList<Container> containers = new ArrayList<>();\n\t\tContainer container = new Container(\"X\", 4, 4, 4, 1000);\n\t\tcontainers.add(container);\n\n\t\tList<BoxItem> products = new ArrayList<>();\n\t\tproducts.add(new BoxItem(new Box(\"1\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"2\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"3\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"4\", 4, 3, 1, 1)));\n\n\t\tLargestAreaFitFirstPackager packager = new LargestAreaFitFirstPackager(containers, true, true, true, 1);\n\t\tContainer pack = packager.pack(products, Long.MAX_VALUE);\t\t\n\t\t\n\t\tContainerProjection p = new ContainerProjection();\n\t\tByteArrayOutputStream bout = new ByteArrayOutputStream();\n\t\tList<Container> a = Arrays.asList(pack);\n\n\t\tSystem.out.println(a);\n\t\t\n\t\tFile file = new File(\"../viewer/public/assets/containers.json\");\n\t\tp.project(a , file);\n\n\t\t\n\t}\n","Method after Refactoring":"\tprotected void pack(List<BouwkampCodes> codes) throws Exception {\n\t\tfor (BouwkampCodes bouwkampCodes : codes) {\n\t\t\tfor (BouwkampCode bouwkampCode : bouwkampCodes.getCodes()) {\n\t\t\t\tlong timestamp = System.currentTimeMillis();\n\t\t\t\tpack(bouwkampCode);\n\t\t\t\tSystem.out.println(\"Packaged \" + bouwkampCode.getName() + \" order \" + bouwkampCode.getOrder() + \" in \" + (System.currentTimeMillis() - timestamp));\n\t\t\t\t\n\t\t\t\tThread.sleep(5000);\n\t\t\t}\n\t\t}\n\t}\n","Extracted Method":"\tprivate void write(List<Container> packList) throws Exception {\n\t\tDefaultPackagingResultVisualizerFactory p = new DefaultPackagingResultVisualizerFactory();\n\t\t\n\t\tFile file = new File(\"../viewer/public/assets/containers.json\");\n\t\tp.visualize(packList , file);\n\t}\n"}
{"Smelly Sample":"\t@Test\n\tpublic void testPackager() throws Exception {\n\t\t\n\t\t// issue 159\n\t\tList<Container> containers = new ArrayList<>();\n\t\tContainer container = new Container(\"X\", 4, 4, 4, 1000);\n\t\tcontainers.add(container);\n\n\t\tList<BoxItem> products = new ArrayList<>();\n\t\tproducts.add(new BoxItem(new Box(\"1\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"2\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"3\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"4\", 4, 3, 1, 1)));\n\n\t\tLargestAreaFitFirstPackager packager = new LargestAreaFitFirstPackager(containers, true, true, true, 1);\n\t\tContainer pack = packager.pack(products, Long.MAX_VALUE);\t\t\n\t\t\n\t\tContainerProjection p = new ContainerProjection();\n\t\tByteArrayOutputStream bout = new ByteArrayOutputStream();\n\t\tList<Container> a = Arrays.asList(pack);\n\n\t\tSystem.out.println(a);\n\t\t\n\t\tFile file = new File(\"../viewer/public/assets/containers.json\");\n\t\tp.project(a , file);\n\n\t\t\n\t}\n","Method after Refactoring":"\tprotected void pack(BouwkampCode bouwkampCode) throws Exception {\n\t\tList<Container> containers = new ArrayList<>();\n\t\tDefaultContainer container = Container.newBuilder().withDescription(\"1\").withEmptyWeight(1).withSize(bouwkampCode.getWidth(), bouwkampCode.getDepth(), 1).withMaxLoadWeight(bouwkampCode.getWidth() * bouwkampCode.getDepth()).build();\n\t\tcontainers.add(container);\n\t\tParallelBruteForcePackager packager = ParallelBruteForcePackager.newBuilder().withExecutorService(executorService).withParallelizationCount(256).withCheckpointsPerDeadlineCheck(1024).withContainers(containers).build();\n\n\t\tList<Integer> squares = new ArrayList<>(); \n\t\tfor (BouwkampCodeLine bouwkampCodeLine : bouwkampCode.getLines()) {\n\t\t\tsquares.addAll(bouwkampCodeLine.getSquares());\n\t\t}\n\n\t\t// map similar items to the same stack item - this actually helps a lot\n\t\tMap<Integer, Integer> frequencyMap = new HashMap<>();\n\t\tsquares.forEach(word ->\n        \tfrequencyMap.merge(word, 1, (v, newV) -> v + newV)\n\t\t);\n\t\t\n\t\tList<StackableItem> products = new ArrayList<>();\n\t\tfor (Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n\t\t\tint square = entry.getKey();\n\t\t\tint count = entry.getValue();\n\t\t\tproducts.add(new StackableItem(Box.newBuilder().withDescription(Integer.toString(square)).withSize(square, square, 1).withRotate3D().withWeight(1).build(), count));\n\t\t}\n\n\t\t// shuffle\n\t\tCollections.shuffle(products);\n\t\t\n\t\tContainer fits = packager.pack(products);\n\t\tassertNotNull(bouwkampCode.getName(), fits);\n\t\tassertEquals(bouwkampCode.getName(), fits.getStack().getSize(), squares.size());\n\t\t\n\t\tfor (StackPlacement stackPlacement : fits.getStack().getPlacements()) {\n\t\t\tStackValue stackValue = stackPlacement.getStackValue();\n\t\t\tSystem.out.println(stackPlacement.getAbsoluteX() + \"x\" + stackPlacement.getAbsoluteY() + \"x\" + stackPlacement.getAbsoluteZ() + \" \" + stackValue.getDx() + \"x\" + stackValue.getDy() + \"x\" + stackValue.getDz());\n\t\t}\n\t\t\n\t\twrite(fits);\n\t}\n","Extracted Method":"\tprivate void write(List<Container> packList) throws Exception {\n\t\tDefaultPackagingResultVisualizerFactory p = new DefaultPackagingResultVisualizerFactory();\n\t\t\n\t\tFile file = new File(\"../viewer/public/assets/containers.json\");\n\t\tp.visualize(packList , file);\n\t}\n"}
{"Smelly Sample":"\t@Test\n\tpublic void testPackager() throws Exception {\n\t\t\n\t\t// issue 159\n\t\tList<Container> containers = new ArrayList<>();\n\t\tContainer container = new Container(\"X\", 4, 4, 4, 1000);\n\t\tcontainers.add(container);\n\n\t\tList<BoxItem> products = new ArrayList<>();\n\t\tproducts.add(new BoxItem(new Box(\"1\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"2\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"3\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"4\", 4, 3, 1, 1)));\n\n\t\tLargestAreaFitFirstPackager packager = new LargestAreaFitFirstPackager(containers, true, true, true, 1);\n\t\tContainer pack = packager.pack(products, Long.MAX_VALUE);\t\t\n\t\t\n\t\tContainerProjection p = new ContainerProjection();\n\t\tByteArrayOutputStream bout = new ByteArrayOutputStream();\n\t\tList<Container> a = Arrays.asList(pack);\n\n\t\tSystem.out.println(a);\n\t\t\n\t\tFile file = new File(\"../viewer/public/assets/containers.json\");\n\t\tp.project(a , file);\n\n\t\t\n\t}\n","Method after Refactoring":"\tprivate void write(Container container) throws Exception {\n\t\twrite(Arrays.asList(container));\n\t}\n","Extracted Method":"\tprivate void write(List<Container> packList) throws Exception {\n\t\tDefaultPackagingResultVisualizerFactory p = new DefaultPackagingResultVisualizerFactory();\n\t\t\n\t\tFile file = new File(\"../viewer/public/assets/containers.json\");\n\t\tp.visualize(packList , file);\n\t}\n"}
{"Smelly Sample":"\t@Test\n\tpublic void testPackager() throws Exception {\n\t\t\n\t\t// issue 159\n\t\tList<Container> containers = new ArrayList<>();\n\t\tContainer container = new Container(\"X\", 4, 4, 4, 1000);\n\t\tcontainers.add(container);\n\n\t\tList<BoxItem> products = new ArrayList<>();\n\t\tproducts.add(new BoxItem(new Box(\"1\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"2\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"3\", 4, 1, 1, 1)));\n\t\tproducts.add(new BoxItem(new Box(\"4\", 4, 3, 1, 1)));\n\n\t\tLargestAreaFitFirstPackager packager = new LargestAreaFitFirstPackager(containers, true, true, true, 1);\n\t\tContainer pack = packager.pack(products, Long.MAX_VALUE);\t\t\n\t\t\n\t\tContainerProjection p = new ContainerProjection();\n\t\tByteArrayOutputStream bout = new ByteArrayOutputStream();\n\t\tList<Container> a = Arrays.asList(pack);\n\n\t\tSystem.out.println(a);\n\t\t\n\t\tFile file = new File(\"../viewer/public/assets/containers.json\");\n\t\tp.project(a , file);\n\n\t\t\n\t}\n","Method after Refactoring":"\t@Test\n\tpublic void testPackager() throws Exception {\n\t\tDefaultContainer container = Container.newBuilder().withDescription(\"1\").withEmptyWeight(1).withSize(3, 2, 1).withMaxLoadWeight(100).build();\n\t\tFastLargestAreaFitFirstPackager packager = FastLargestAreaFitFirstPackager.newBuilder().withContainers(container).build();\n\t\t\n\t\tList<StackableItem> products = new ArrayList<>();\n\n\t\tproducts.add(new StackableItem(Box.newBuilder().withDescription(\"A\").withSize(2, 1, 1).withRotate3D().withWeight(1).build(), 1));\n\t\tproducts.add(new StackableItem(Box.newBuilder().withDescription(\"B\").withSize(2, 1, 1).withRotate3D().withWeight(1).build(), 1));\n\t\tproducts.add(new StackableItem(Box.newBuilder().withDescription(\"C\").withSize(2, 1, 1).withRotate3D().withWeight(1).build(), 1));\n\n\t\tContainer fits = packager.pack(products);\n\t\tassertNotNull(fits);\n\t\t\n\t\tSystem.out.println(fits.getStack().getPlacements());\n\t\tSystem.out.println(container);\n\t\t\n\t\twrite(container);\n\t}\n","Extracted Method":"\tprotected void pack(BouwkampCode bouwkampCode) throws Exception {\n\t\tList<Container> containers = new ArrayList<>();\n\t\tDefaultContainer container = Container.newBuilder().withDescription(\"1\").withEmptyWeight(1).withSize(bouwkampCode.getWidth(), bouwkampCode.getDepth(), 1).withMaxLoadWeight(bouwkampCode.getWidth() * bouwkampCode.getDepth()).build();\n\t\tcontainers.add(container);\n\t\tParallelBruteForcePackager packager = ParallelBruteForcePackager.newBuilder().withExecutorService(executorService).withParallelizationCount(256).withCheckpointsPerDeadlineCheck(1024).withContainers(containers).build();\n\n\t\tList<Integer> squares = new ArrayList<>(); \n\t\tfor (BouwkampCodeLine bouwkampCodeLine : bouwkampCode.getLines()) {\n\t\t\tsquares.addAll(bouwkampCodeLine.getSquares());\n\t\t}\n\n\t\t// map similar items to the same stack item - this actually helps a lot\n\t\tMap<Integer, Integer> frequencyMap = new HashMap<>();\n\t\tsquares.forEach(word ->\n        \tfrequencyMap.merge(word, 1, (v, newV) -> v + newV)\n\t\t);\n\t\t\n\t\tList<StackableItem> products = new ArrayList<>();\n\t\tfor (Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n\t\t\tint square = entry.getKey();\n\t\t\tint count = entry.getValue();\n\t\t\tproducts.add(new StackableItem(Box.newBuilder().withDescription(Integer.toString(square)).withSize(square, square, 1).withRotate3D().withWeight(1).build(), count));\n\t\t}\n\n\t\t// shuffle\n\t\tCollections.shuffle(products);\n\t\t\n\t\tContainer fits = packager.pack(products);\n\t\tassertNotNull(bouwkampCode.getName(), fits);\n\t\tassertEquals(bouwkampCode.getName(), fits.getStack().getSize(), squares.size());\n\t\t\n\t\tfor (StackPlacement stackPlacement : fits.getStack().getPlacements()) {\n\t\t\tStackValue stackValue = stackPlacement.getStackValue();\n\t\t\tSystem.out.println(stackPlacement.getAbsoluteX() + \"x\" + stackPlacement.getAbsoluteY() + \"x\" + stackPlacement.getAbsoluteZ() + \" \" + stackValue.getDx() + \"x\" + stackValue.getDy() + \"x\" + stackValue.getDz());\n\t\t}\n\t\t\n\t\twrite(fits);\n\t}\n"}
{"Smelly Sample":"\tprivate static int fit2D(PermutationRotationIterator rotator, int index, List<Placement> placements, Container holder, Placement usedSpace, BooleanSupplier interrupt) {\n\t\t// add used space box now\n\t\t// there is up to 2 possible free spaces\n\t\tholder.add(usedSpace);\n\n\t\tif (index >= rotator.length()) {\n\t\t\treturn index;\n\t\t}\n\n\t\tif (interrupt.getAsBoolean()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tBox nextBox = rotator.get(index);\n\t\tif (nextBox.getWeight() > holder.getFreeWeight()) {\n\t\t\treturn index;\n\t\t}\n\n\t\tPlacement nextPlacement = placements.get(index);\n\t\tnextPlacement.setBox(nextBox);\n\n\t\tboolean room = isFreeSpace(usedSpace.getSpace(), usedSpace.getBox(), nextPlacement);\n\t\tif (room) {\n\t\t\tindex++;\n\t\t\t// the correct space dimensions is copied into the next placement\n\n\t\t\t// attempt to fit in the remaining (usually smaller) space first\n\n\t\t\t// stack in the 'sibling' space - the space left over between the used box and the selected free space\n\t\t\tif (index < rotator.length()) {\n\t\t\t\tSpace remainder = nextPlacement.getSpace().getRemainder();\n\t\t\t\tif (remainder.nonEmpty()) {\n\t\t\t\t\tBox box = rotator.get(index);\n\n\t\t\t\t\tif (box.getWeight() <= holder.getFreeWeight()) {\n\t\t\t\t\t\tif (box.fitsInside3D(remainder)) {\n\t\t\t\t\t\t\tPlacement placement = placements.get(index);\n\t\t\t\t\t\t\tplacement.setBox(box);\n\n\t\t\t\t\t\t\tindex++;\n\n\t\t\t\t\t\t\tplacement.getSpace().copyFrom(remainder);\n\t\t\t\t\t\t\tplacement.getSpace().setParent(remainder);\n\t\t\t\t\t\t\tplacement.getSpace().getRemainder().setParent(remainder);\n\n\t\t\t\t\t\t\tindex = fit2D(rotator, index, placements, holder, placement, interrupt);\n\t\t\t\t\t\t\tif(index == -1) {\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// fit the next box in the selected free space\n\t\t\t// double check that there is still free weight\n\t\t\tif (holder.getFreeWeight() >= nextBox.getWeight()) {\n\t\t\t\tindex = fit2D(rotator, index, placements, holder, nextPlacement, interrupt);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}  else {\n\t\t\t// no additional boxes can be placed along the level floor\n\t\t}\n\t\t\n\t\t// also use the space above the placed box, if any.\n\t\tif (index < rotator.length()) {\n\t\t\tif(usedSpace.getSpace().getHeight() > usedSpace.getBox().getHeight()) {\n\t\t\t\t// so there is some free room; between the used space and the level height\n\n\t\t\t\tnextBox = rotator.get(index);\n\t\t\t\tif (nextBox.getWeight() > holder.getFreeWeight()) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\n\t\t\t\t// the level by level approach is somewhat crude, but at least some of the inefficiency\n\t\t\t\t// can be avoided this way\n\t\t\t\tSpace free = usedSpace.getSpace();\n\t\t\t\tBox used = usedSpace.getBox();\n\t\t\t\t\n\t\t\t\tSpace above;\n\t\t\t\tif(!room) {\n\t\t\t\t\t// full width / depth\n\t\t\t\t\tabove = new Space(\n\t\t\t\t\t\t\tfree.getWidth(), \n\t\t\t\t\t\t\tfree.getDepth(), \n\t\t\t\t\t\t\tfree.getHeight() - used.getHeight(),\n\t\t\t\t\t\t\tfree.getX(),\n\t\t\t\t\t\t\tfree.getY(),\n\t\t\t\t\t\t\tfree.getZ() + used.getHeight()\n\t\t\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// just directly above the used space\n\t\t\t\t\t\n\t\t\t\t\t// TODO possible include the sibling space if no box was fitted there\n\t\t\t\t\tabove = new Space(\n\t\t\t\t\t\t\tused.getWidth(), \n\t\t\t\t\t\t\tused.getDepth(), \n\t\t\t\t\t\t\tfree.getHeight() - used.getHeight(),\n\t\t\t\t\t\t\tfree.getX(),\n\t\t\t\t\t\t\tfree.getY(),\n\t\t\t\t\t\t\tfree.getZ() + used.getHeight()\n\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPlacement placement = placements.get(index);\n\t\t\t\tSpace levelSpace = placement.getSpace();\n\t\t\t\tlevelSpace.copyFrom(above);\n\t\t\t\t\n\t\t\t\tplacement.setBox(nextBox);\n\n\t\t\t\tlevelSpace.setParent(usedSpace.getSpace());\n\t\t\t\tlevelSpace.getRemainder().setParent(usedSpace.getSpace());\n\t\t\t\t\n\t\t\t\tif (above.fitsInside3D(nextBox)) {\n\t\t\t\t\tindex++;\n\n\t\t\t\t\tindex = fit2D(rotator, index, placements, holder, nextPlacement, interrupt);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\n\t\treturn index;\n\t}\n","Method after Refactoring":"\tprotected static int fit2D(PermutationRotationIterator rotator, int index, List<Placement> placements, Container holder, Placement usedSpace, BooleanSupplier interrupt) {\n\t\t// add used space box now\n\t\t// there is up to 2 possible free spaces\n\t\tholder.add(usedSpace);\n\n\t\tif (index >= rotator.length()) {\n\t\t\treturn index;\n\t\t}\n\n\t\tif (interrupt.getAsBoolean()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tBox nextBox = rotator.get(index);\n\t\tif (nextBox.getWeight() > holder.getFreeWeight()) {\n\t\t\treturn index;\n\t\t}\n\n\t\tPlacement nextPlacement = placements.get(index);\n\t\tnextPlacement.setBox(nextBox);\n\n\t\tboolean room = isFreeSpace(usedSpace.getSpace(), usedSpace.getBox(), nextPlacement);\n\t\tif (room) {\n\t\t\tindex++;\n\t\t\t// the correct space dimensions is copied into the next placement\n\n\t\t\t// attempt to fit in the remaining (usually smaller) space first\n\n\t\t\t// stack in the 'sibling' space - the space left over between the used box and the selected free space\n\t\t\tif (index < rotator.length()) {\n\t\t\t\tSpace remainder = nextPlacement.getSpace().getRemainder();\n\t\t\t\tif (remainder.nonEmpty()) {\n\t\t\t\t\tBox box = rotator.get(index);\n\n\t\t\t\t\tif (box.getWeight() <= holder.getFreeWeight()) {\n\t\t\t\t\t\tif (box.fitsInside3D(remainder)) {\n\t\t\t\t\t\t\tPlacement placement = placements.get(index);\n\t\t\t\t\t\t\tplacement.setBox(box);\n\n\t\t\t\t\t\t\tindex++;\n\n\t\t\t\t\t\t\tplacement.getSpace().copyFrom(remainder);\n\t\t\t\t\t\t\tplacement.getSpace().setParent(remainder);\n\t\t\t\t\t\t\tplacement.getSpace().getRemainder().setParent(remainder);\n\n\t\t\t\t\t\t\tindex = fit2D(rotator, index, placements, holder, placement, interrupt);\n\t\t\t\t\t\t\tif(index == -1) {\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// fit the next box in the selected free space\n\t\t\t// double check that there is still free weight\n\t\t\tif (holder.getFreeWeight() >= nextBox.getWeight()) {\n\t\t\t\tindex = fit2D(rotator, index, placements, holder, nextPlacement, interrupt);\n\t\t\t\tif(index == -1) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}  else {\n\t\t\t// no additional boxes can be placed along the level floor\n\t\t}\n\n\t\treturn index;\n\t}\n","Extracted Method":"\tprotected static int fitWithin(Level level, Space levelSpace, PermutationRotationIterator rotator, int index, List<Placement> placements, Container holder, BooleanSupplier interrupt) {\n\t\t// also use the space above the placed box, if any.\n\t\t\n\t\t// level size increases as this loop runs\n\t\tfor(int i = 0; i < level.size() && index < rotator.length(); i++) { \n\t\t\t\n\t\t\tPlacement placement = level.get(i);\n\t\t\tBox placedBox = placement.getBox();\n\t\t\tSpace placedSpace = placement.getSpace();\n\t\t\t\n\t\t\tint height = (levelSpace.getZ() + levelSpace.getHeight()) - (placedSpace.getZ() + placedBox.getHeight());\n\t\t\tif(height > 0) {\n\t\t\t\tBox nextBox = rotator.get(index);\n\t\t\t\tif (nextBox.getWeight() > holder.getFreeWeight()) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSpace abovePlacedBox = new Space(\n\t\t\t\t\t\tplacedBox.getWidth(), \n\t\t\t\t\t\tplacedBox.getDepth(), \n\t\t\t\t\t\theight,\n\t\t\t\t\t\tlevelSpace.getX(),\n\t\t\t\t\t\tlevelSpace.getY(),\n\t\t\t\t\t\tplacedSpace.getZ() + placedBox.getHeight()\n\t\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\tif (nextBox.fitsInside3D(abovePlacedBox)) {\n\t\t\t\t\tPlacement nextPlacement = placements.get(index);\n\t\t\t\t\tnextPlacement.setBox(nextBox);\n\n\t\t\t\t\tindex++;\n\n\t\t\t\t\tnextPlacement.getSpace().copyFrom(abovePlacedBox);\n\t\t\t\t\tnextPlacement.getSpace().setParent(levelSpace);\n\t\t\t\t\tnextPlacement.getSpace().getRemainder().setParent(levelSpace);\n\n\t\t\t\t\tindex = fit2D(rotator, index, placements, holder, nextPlacement, interrupt);\n\t\t\t\t\tif(index == -1) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t\t\n\t}\n"}
{"Smelly Sample":"\tpublic Dimension(String name, int w, int d, int h) {\n\t\tthis.name = name;\n\n\t\tthis.depth = d;\n\t\tthis.width = w;\n\t\tthis.height = h;\n\n\t\tthis.volume = ((long)depth) * ((long)width) * ((long)height);\n\t}\n","Method after Refactoring":"\tpublic Dimension(String name, int w, int d, int h) {\n\t\tthis.name = name;\n\n\t\tthis.depth = d;\n\t\tthis.width = w;\n\t\tthis.height = h;\n\n\t\tcalculateVolume();\n\t}\n","Extracted Method":"\tprotected void calculateVolume() {\n\t\tthis.volume = ((long)depth) * ((long)width) * ((long)height);\n\t}\n"}
{"Smelly Sample":"\tpublic LAFFResult pack(List<Box> containerProducts, Container targetContainer,  BooleanSupplier interrupt) {\n\t\tContainer holder = new Container(targetContainer);\n\n\t\tDimension freeSpace = targetContainer;\n\n\t\twhile(!containerProducts.isEmpty()) {\n\t\t\tif(interrupt.getAsBoolean()) {\n\t\t\t\t// fit2d below might have returned due to deadline\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// choose the box with the largest surface area, that fits\n\t\t\t// if the same then the one with minimum height\n\n\t\t\t// use a special case for boxes with full height\n\t\t\tBox currentBox = null;\n\t\t\tint currentIndex = -1;\n\n\t\t\tboolean fullHeight = false;\n\t\t\tfor (int i = 0; i < containerProducts.size(); i++) {\n\t\t\t\tBox box = containerProducts.get(i);\n\t\t\t\tboolean fits;\n\t\t\t\tif(rotate3D) {\n\t\t\t\t\tfits = box.rotateLargestFootprint3D(freeSpace);\n\t\t\t\t} else {\n\t\t\t\t\tfits = box.fitRotate2D(freeSpace);\n\t\t\t\t}\n\t\t\t\tif(fits && box.getWeight() <= holder.getFreeWeight()) {\n\t\t\t\t\tif(currentBox == null) {\n\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\tcurrentIndex = i;\n\n\t\t\t\t\t\tfullHeight = box.getHeight() == freeSpace.getHeight();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(fullHeight) {\n\t\t\t\t\t\t\tif(box.getHeight() == freeSpace.getHeight()) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(box.getHeight() == freeSpace.getHeight()) {\n\t\t\t\t\t\t\t\tfullHeight = true;\n\n\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t} else if(footprintFirst) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t} else if(currentBox.getFootprint() == box.getFootprint() && currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t} else if(currentBox.getHeight() == box.getHeight() && currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(currentBox == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// current box should have the optimal orientation already\n\t\t\t// create a space which holds the full level\n\t\t\tSpace levelSpace = new Space(\n\t\t\t\t\t\ttargetContainer.getWidth(),\n\t\t\t\t\t\ttargetContainer.getDepth(),\n\t\t\t\t\t\tcurrentBox.getHeight(),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tholder.getStackHeight()\n\t\t\t\t\t\t);\n\n\t\t\tholder.addLevel();\n\t\t\tcontainerProducts.remove(currentIndex);\n\n\t\t\tif(!fit2D(containerProducts, holder, currentBox, levelSpace, interrupt)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfreeSpace = holder.getFreeSpace();\n\t\t}\n\n\t\treturn new LAFFResult(containerProducts, holder);\n\t}\n","Method after Refactoring":"\tpublic LAFFResult pack(List<Box> containerProducts, Container targetContainer,  BooleanSupplier interrupt) {\n\t\tContainer holder = new Container(targetContainer);\n\n\t\tDimension freeSpace = targetContainer;\n\n\t\twhile(!containerProducts.isEmpty()) {\n\t\t\tif(interrupt.getAsBoolean()) {\n\t\t\t\t// fit2d below might have returned due to deadline\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// choose the box with the largest surface area, that fits\n\t\t\t// if the same then the one with minimum height\n\t\t\tint currentIndex = getBestBox(holder, freeSpace, containerProducts);\n\n\t\t\tif(currentIndex == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tBox currentBox = containerProducts.get(currentIndex);\n\n\t\t\t// current box should have the optimal orientation already\n\t\t\t// create a space which holds the full level\n\t\t\tSpace levelSpace = new Space(\n\t\t\t\t\t\ttargetContainer.getWidth(),\n\t\t\t\t\t\ttargetContainer.getDepth(),\n\t\t\t\t\t\tcurrentBox.getHeight(),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tholder.getStackHeight()\n\t\t\t\t\t\t);\n\n\t\t\tholder.addLevel();\n\t\t\tcontainerProducts.remove(currentIndex);\n\n\t\t\tif(!fit2D(containerProducts, holder, currentBox, levelSpace, interrupt)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfreeSpace = holder.getFreeSpace();\n\t\t}\n\n\t\treturn new LAFFResult(containerProducts, holder);\n\t}\n","Extracted Method":"\tprotected int getBestBox(Container holder, Dimension freeSpace, List<Box> containerProducts) {\n\t\t// use a special case for boxes with full height\n\t\tint currentIndex = -1;\n\n\t\tboolean fullHeight = false;\n\t\tfor (int i = 0; i < containerProducts.size(); i++) {\n\t\t\tBox box = containerProducts.get(i);\n\t\t\t\n\t\t\tboolean fits;\n\t\t\tif(rotate3D) {\n\t\t\t\tfits = box.rotateLargestFootprint3D(freeSpace);\n\t\t\t} else {\n\t\t\t\tfits = box.fitRotate2D(freeSpace);\n\t\t\t}\n\t\t\tif(fits && box.getWeight() <= holder.getFreeWeight()) {\n\t\t\t\tif(currentIndex == -1) {\n\t\t\t\t\tcurrentIndex = i;\n\n\t\t\t\t\tfullHeight = box.getHeight() == freeSpace.getHeight();\n\t\t\t\t} else {\n\t\t\t\t\tif(fullHeight) {\n\t\t\t\t\t\tif(box.getHeight() == freeSpace.getHeight()) {\n\t\t\t\t\t\t\tif(containerProducts.get(currentIndex).getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(box.getHeight() == freeSpace.getHeight()) {\n\t\t\t\t\t\t\tfullHeight = true;\n\n\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t} else if(footprintFirst) {\n\t\t\t\t\t\t\tif(containerProducts.get(currentIndex).getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t} else if(containerProducts.get(currentIndex).getFootprint() == box.getFootprint() && containerProducts.get(currentIndex).getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(containerProducts.get(currentIndex).getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t} else if(containerProducts.get(currentIndex).getHeight() == box.getHeight() && containerProducts.get(currentIndex).getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn currentIndex;\n\t}\n"}
{"Smelly Sample":"\tprivate Placement bestVolumePlacement(List<Box> containerProducts, Space[] spaces, int freeWeight) {\n\n\t\tBox bestBox = null;\n\t\tSpace bestSpace = null;\n\t\tfor(Space space : spaces) {\n\t\t\tif(space == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Box box : containerProducts) {\n\t\t\t\tif(box.getWeight() > freeWeight) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(rotate3D) {\n\t\t\t\t\tif(box.canFitInside3D(space)) {\n\t\t\t\t\t\tif(bestBox == null) {\n\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\tbestSpace = space;\n\n\t\t\t\t\t\t\tbestBox.fitRotate3DSmallestFootprint(bestSpace);\n\t\t\t\t\t\t} else if(bestBox.getVolume() < box.getVolume()) {\n\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\tbestSpace = space;\n\n\t\t\t\t\t\t\tbestBox.fitRotate3DSmallestFootprint(bestSpace);\n\t\t\t\t\t\t} else if(bestBox.getVolume() == box.getVolume()) {\n\t\t\t\t\t\t\t// determine lowest fit\n\t\t\t\t\t\t\tbox.fitRotate3DSmallestFootprint(space);\n\n\t\t\t\t\t\t\tif(box.getFootprint() < bestBox.getFootprint()) {\n\t\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\t\tbestSpace = space;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// TODO if all else is equal, which free space is preferred?\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(box.canFitInside2D(space)) {\n\t\t\t\t\t\tif(bestBox == null) {\n\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\tbestSpace = space;\n\t\t\t\t\t\t} else if(bestBox.getVolume() < box.getVolume()) {\n\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\tbestSpace = space;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO use the aspect ratio in some meaningful way\n\n\t\t\t\t\t\t// TODO if all else is equal, which free space is preferred?\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(bestBox != null) {\n\t\t\treturn new Placement(bestSpace, bestBox);\n\t\t}\n\t\treturn null;\n\t}\n","Method after Refactoring":"\tprotected Placement getBestBoxAndSpace(List<Box> containerProducts, Space[] spaces, int freeWeight) {\n\n\t\t// this method could have many implementation\n\t\t// it focuses on getting the biggest box possible fitted.\n\t\t// \n\t\t// an alternative implementation would be one that \n\t\t// measure the amount of wasted space and/or maximizes largest leftover area\n\t\t\n\t\tBox bestBox = null;\n\t\tSpace bestSpace = null;\n\t\tfor(Space space : spaces) {\n\t\t\tif(space == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tBox box = getBestBoxForSpace(containerProducts, space, freeWeight);\n\t\t\tif(box == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean best;\n\t\t\tif(bestBox == null) {\n\t\t\t\tbest = true;\n\t\t\t} else {\n\t\t\t\tint compare;\n\t\t\t\tif(rotate3D) {\n\t\t\t\t\tcompare = isBetter3D(bestBox, box, space);\n\t\t\t\t} else {\n\t\t\t\t\tcompare = isBetter2D(bestBox, box);\n\t\t\t\t}\n\t\t\t\tif(compare < 0) {\n\t\t\t\t\tbest = true;\n\t\t\t\t} else if(compare == 0) {\n\t\t\t\t\t// if all is equal, prefer smallest space as a crude indicator on \n\t\t\t\t\t// how 'difficult' matching the box was. \n\n\t\t\t\t\tbest = space.getVolume() < bestSpace.getVolume();\n\t\t\t\t} else {\n\t\t\t\t\tbest = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(best) {\n\t\t\t\tbestBox = box;\n\t\t\t\tbestSpace = space;\n\t\t\t}\n\t\t}\n\t\tif(bestBox != null) {\n\t\t\tif(rotate3D) {\n\t\t\t\tbestBox.fitRotate3DSmallestFootprint(bestSpace);\n\t\t\t}\n\t\t\t\n\t\t\treturn new Placement(bestSpace, bestBox);\n\t\t}\n\t\treturn null;\n\t}\n","Extracted Method":"\t/**\n\t * Is box b strictly better than a?\n\t * \n\t * @param a box\n\t * @param b box\n\t * @param space free space\n\t * @return -1 if b is better, 0 if equal, 1 if b is better\n\t */\n\t\n\tprotected int isBetter3D(Box a, Box b, Space space) {\n\t\tint compare = Long.compare(a.getVolume(), b.getVolume());\n\t\tif(compare != 0) {\n\t\t\treturn compare;\n\t\t}\n\t\t// determine lowest fit\n\t\ta.fitRotate3DSmallestFootprint(space);\n\t\tb.fitRotate3DSmallestFootprint(space);\n\n\t\treturn Long.compare(b.getFootprint(), a.getFootprint()); // i.e. smaller i better\n\t}\n"}
{"Smelly Sample":"\t/**\n\t * Return a list of containers which holds all the boxes in the argument\n\t *\n\t * @param boxes     list of boxes to fit in a container\n\t * @param limit     maximum number of containers\n\t * @param deadline  the system time in milliseconds at which the search should be aborted\n\t * @param interrupt When true, the computation is interrupted as soon as possible.\n\t * @return index of container if match, -1 if not\n\t */\n\tpublic List<Container> packList(List<BoxItem> boxes, int limit, long deadline, AtomicBoolean interrupt) {\n\n\t\tList<Container> containers = filterByVolumeAndWeight(toBoxes(boxes, true), Arrays.asList(this.containers), limit);\n\t\tif (containers.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tAdapter pack = adapter();\n\t\tpack.initialize(boxes, containers);\n\n\t\tList<Container> containerPackResults = new ArrayList<>();\n\n\t\t// binary search: not as simple as in the single-container use-case; discarding containers would need some kind\n\t\t// of criteria which could be trivially calculated, perhaps on volume.\n\t\tdo {\n\t\t\tPackResult best = null;\n\t\t\tfor (int i = 0; i < containers.size(); i++) {\n\n\t\t\t\tif (System.currentTimeMillis() > deadline || interrupt.get()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tPackResult result = pack.attempt(i, deadline, interrupt);\n\t\t\t\tif (result == null) {\n\t\t\t\t\treturn null; // timeout\n\t\t\t\t}\n\n\t\t\t\tif (!result.isEmpty()) {\n\t\t\t\t\tif (best == null || result.packsMoreBoxesThan(best)) {\n\t\t\t\t\t\tbest = result;\n\n\t\t\t\t\t\tif (!pack.hasMore(best)) { // will not match any better than this\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (best == null) {\n\t\t\t\t// negative result\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tboolean end = !pack.hasMore(best);\n\n\t\t\tcontainerPackResults.add(pack.accepted(best));\n\n\t\t\tif (end) {\n\t\t\t\t// positive result\n\t\t\t\treturn containerPackResults;\n\t\t\t}\n\n\t\t} while (containerPackResults.size() < limit);\n\n\t\treturn null;\n\t}\n","Method after Refactoring":"\t/**\n\t * Return a list of containers which holds all the boxes in the argument\n\t *\n\t * @param boxes     list of boxes to fit in a container\n\t * @param limit     maximum number of containers\n\t * @param deadline  the system time in milliseconds at which the search should be aborted\n\t * @param interrupt When true, the computation is interrupted as soon as possible.\n\t * @return index of container if match, -1 if not\n\t */\n\tpublic List<Container> packList(List<BoxItem> boxes, int limit, long deadline, AtomicBoolean interrupt) {\n\t\treturn packList(boxes, limit, () -> System.currentTimeMillis() > deadline || interrupt.get());\n\t}\n","Extracted Method":"\t/**\n\t * Return a list of containers which holds all the boxes in the argument\n\t *\n\t * @param boxes     list of boxes to fit in a container\n\t * @param limit     maximum number of containers\n\t * @param interrupt When true, the computation is interrupted as soon as possible.\n\t * @return index of container if match, -1 if not\n\t */\n\tpublic List<Container> packList(List<BoxItem> boxes, int limit, BooleanSupplier interrupt) {\n\t\tList<Container> containers = filterByVolumeAndWeight(toBoxes(boxes, true), Arrays.asList(this.containers), limit);\n\t\tif (containers.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tAdapter pack = adapter();\n\t\tpack.initialize(boxes, containers);\n\n\t\tList<Container> containerPackResults = new ArrayList<>();\n\n\t\t// binary search: not as simple as in the single-container use-case; discarding containers would need some kind\n\t\t// of criteria which could be trivially calculated, perhaps on volume.\n\t\tdo {\n\t\t\tPackResult best = null;\n\t\t\tfor (int i = 0; i < containers.size(); i++) {\n\n\t\t\t\tif (interrupt.getAsBoolean()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tPackResult result = pack.attempt(i, interrupt);\n\t\t\t\tif (result == null) {\n\t\t\t\t\treturn null; // timeout\n\t\t\t\t}\n\n\t\t\t\tif (!result.isEmpty()) {\n\t\t\t\t\tif (best == null || result.packsMoreBoxesThan(best)) {\n\t\t\t\t\t\tbest = result;\n\n\t\t\t\t\t\tif (!pack.hasMore(best)) { // will not match any better than this\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (best == null) {\n\t\t\t\t// negative result\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tboolean end = !pack.hasMore(best);\n\n\t\t\tcontainerPackResults.add(pack.accepted(best));\n\n\t\t\tif (end) {\n\t\t\t\t// positive result\n\t\t\t\treturn containerPackResults;\n\t\t\t}\n\n\t\t} while (containerPackResults.size() < limit);\n\n\t\treturn null;\n\t}\n"}
{"Smelly Sample":"\tpublic BruteForceResult pack(List<Placement> placements, Container container, PermutationRotationIterator rotator, long deadline) {\n\n\t\tContainer holder = new Container(container);\n\n\t\tBruteForceResult result = new BruteForceResult(rotator, placements, holder);\n\n\t\t// iterator over all permutations\n\t\tdo {\n\t\t\tif(System.currentTimeMillis() > deadline) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// iterator over all rotations\n\n\t\t\tdo {\n\t\t\t\tint count = pack(placements, holder, rotator, deadline, holder, 0);\n\t\t\t\tif(count == Integer.MIN_VALUE) {\n\t\t\t\t\treturn null; // timeout\n\t\t\t\t} else {\n\t\t\t\t\tholder.clear();\n\n\t\t\t\t\tif(count == placements.size()) {\n\t\t\t\t\t\tif(accept()) {\n\t\t\t\t\t\t\tresult.setCount(count);\n\t\t\t\t\t\t\tresult.setState(rotator.getState());\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(count > 0) {\n\t\t\t\t\t\t// continue search, but see if this is the best fit so far\n\t\t\t\t\t\tif(count > result.getCount()) {\n\t\t\t\t\t\t\tresult.setCount(count);\n\t\t\t\t\t\t\tresult.setState(rotator.getState());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while(rotator.nextRotation());\n\t\t} while(rotator.nextPermutation());\n\n\t\treturn result;\n\t}\n","Method after Refactoring":"\tpublic BruteForceResult pack(List<Placement> placements, Container container, PermutationRotationIterator rotator, long deadline) {\n\t\treturn pack(placements, container, rotator, deadline, new AtomicBoolean(false));\n\t}\n","Extracted Method":"\tpublic BruteForceResult pack(List<Placement> placements, Container container, PermutationRotationIterator rotator, long deadline, AtomicBoolean interrupt) {\n\n\t\tContainer holder = new Container(container);\n\n\t\tBruteForceResult result = new BruteForceResult(rotator, placements, holder);\n\n\t\t// iterator over all permutations\n\t\tdo {\n\t\t\tif(System.currentTimeMillis() > deadline || interrupt.get()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// iterator over all rotations\n\n\t\t\tdo {\n\t\t\t\tint count = pack(placements, holder, rotator, deadline, holder, 0, interrupt);\n\t\t\t\tif(count == Integer.MIN_VALUE) {\n\t\t\t\t\treturn null; // timeout\n\t\t\t\t} else {\n\t\t\t\t\tholder.clear();\n\n\t\t\t\t\tif(count == placements.size()) {\n\t\t\t\t\t\tif(accept()) {\n\t\t\t\t\t\t\tresult.setCount(count);\n\t\t\t\t\t\t\tresult.setState(rotator.getState());\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(count > 0) {\n\t\t\t\t\t\t// continue search, but see if this is the best fit so far\n\t\t\t\t\t\tif(count > result.getCount()) {\n\t\t\t\t\t\t\tresult.setCount(count);\n\t\t\t\t\t\t\tresult.setState(rotator.getState());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while(rotator.nextRotation());\n\t\t} while(rotator.nextPermutation());\n\n\t\treturn result;\n\t}\n"}
{"Smelly Sample":"\t/**\n\t *\n\t * Return a container which holds all the boxes in the argument\n\t *\n\t * @param containerProducts list of boxes to fit in a container.\n\t * @param targetContainer the container to fit within\n\t * @param deadline the system time in milliseconds at which the search should be aborted\n\t * @return null if no match, or deadline reached\n\t */\n\n\tpublic LAFFResult pack(List<Box> containerProducts, Container targetContainer, long deadline) {\n\t\tContainer holder = new Container(targetContainer);\n\n\t\tDimension freeSpace = targetContainer;\n\n\t\twhile(!containerProducts.isEmpty()) {\n\t\t\tif(System.currentTimeMillis() > deadline) {\n\t\t\t\t// fit2d below might have returned due to deadline\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// choose the box with the largest surface area, that fits\n\t\t\t// if the same then the one with minimum height\n\n\t\t\t// use a special case for boxes with full height\n\t\t\tBox currentBox = null;\n\t\t\tint currentIndex = -1;\n\n\t\t\tboolean fullHeight = false;\n\t\t\tfor (int i = 0; i < containerProducts.size(); i++) {\n\t\t\t\tBox box = containerProducts.get(i);\n\t\t\t\tboolean fits;\n\t\t\t\tif(rotate3D) {\n\t\t\t\t\tfits = box.rotateLargestFootprint3D(freeSpace);\n\t\t\t\t} else {\n\t\t\t\t\tfits = box.fitRotate2D(freeSpace);\n\t\t\t\t}\n\t\t\t\tif(fits && box.getWeight() <= targetContainer.getFreeWeight()) {\n\t\t\t\t\tif(currentBox == null) {\n\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\tcurrentIndex = i;\n\n\t\t\t\t\t\tfullHeight = box.getHeight() == freeSpace.getHeight();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(fullHeight) {\n\t\t\t\t\t\t\tif(box.getHeight() == freeSpace.getHeight()) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(box.getHeight() == freeSpace.getHeight()) {\n\t\t\t\t\t\t\t\tfullHeight = true;\n\n\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t} else if(footprintFirst) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t} else if(currentBox.getFootprint() == box.getFootprint() && currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t} else if(currentBox.getHeight() == box.getHeight() && currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(currentBox == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// current box should have the optimal orientation already\n\t\t\t// create a space which holds the full level\n\t\t\tSpace levelSpace = new Space(\n\t\t\t\t\t\ttargetContainer.getWidth(),\n\t\t\t\t\t\ttargetContainer.getDepth(),\n\t\t\t\t\t\tcurrentBox.getHeight(),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tholder.getStackHeight()\n\t\t\t\t\t\t);\n\n\t\t\tholder.addLevel();\n\t\t\tcontainerProducts.remove(currentIndex);\n\n\t\t\tif(!fit2D(containerProducts, holder, currentBox, levelSpace, deadline)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfreeSpace = holder.getFreeSpace();\n\t\t}\n\n\t\treturn new LAFFResult(containerProducts, holder);\n\t}\n","Method after Refactoring":"\t/**\n\t *\n\t * Return a container which holds all the boxes in the argument\n\t *\n\t * @param containerProducts list of boxes to fit in a container.\n\t * @param targetContainer the container to fit within\n\t * @param deadline the system time in milliseconds at which the search should be aborted\n\t * @return null if no match, or deadline reached\n\t */\n\n\tpublic LAFFResult pack(List<Box> containerProducts, Container targetContainer, long deadline) {\n\t\treturn pack(containerProducts, targetContainer, deadline, new AtomicBoolean(false));\n\t}\n","Extracted Method":"\tpublic LAFFResult pack(List<Box> containerProducts, Container targetContainer, long deadline, AtomicBoolean interrupt) {\n\t\tContainer holder = new Container(targetContainer);\n\n\t\tDimension freeSpace = targetContainer;\n\n\t\twhile(!containerProducts.isEmpty()) {\n\t\t\tif(System.currentTimeMillis() > deadline || interrupt.get()) {\n\t\t\t\t// fit2d below might have returned due to deadline\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// choose the box with the largest surface area, that fits\n\t\t\t// if the same then the one with minimum height\n\n\t\t\t// use a special case for boxes with full height\n\t\t\tBox currentBox = null;\n\t\t\tint currentIndex = -1;\n\n\t\t\tboolean fullHeight = false;\n\t\t\tfor (int i = 0; i < containerProducts.size(); i++) {\n\t\t\t\tBox box = containerProducts.get(i);\n\t\t\t\tboolean fits;\n\t\t\t\tif(rotate3D) {\n\t\t\t\t\tfits = box.rotateLargestFootprint3D(freeSpace);\n\t\t\t\t} else {\n\t\t\t\t\tfits = box.fitRotate2D(freeSpace);\n\t\t\t\t}\n\t\t\t\tif(fits && box.getWeight() <= targetContainer.getFreeWeight()) {\n\t\t\t\t\tif(currentBox == null) {\n\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\tcurrentIndex = i;\n\n\t\t\t\t\t\tfullHeight = box.getHeight() == freeSpace.getHeight();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(fullHeight) {\n\t\t\t\t\t\t\tif(box.getHeight() == freeSpace.getHeight()) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(box.getHeight() == freeSpace.getHeight()) {\n\t\t\t\t\t\t\t\tfullHeight = true;\n\n\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t} else if(footprintFirst) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t} else if(currentBox.getFootprint() == box.getFootprint() && currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t} else if(currentBox.getHeight() == box.getHeight() && currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t\tcurrentIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(currentBox == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// current box should have the optimal orientation already\n\t\t\t// create a space which holds the full level\n\t\t\tSpace levelSpace = new Space(\n\t\t\t\t\t\ttargetContainer.getWidth(),\n\t\t\t\t\t\ttargetContainer.getDepth(),\n\t\t\t\t\t\tcurrentBox.getHeight(),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tholder.getStackHeight()\n\t\t\t\t\t\t);\n\n\t\t\tholder.addLevel();\n\t\t\tcontainerProducts.remove(currentIndex);\n\n\t\t\tif(!fit2D(containerProducts, holder, currentBox, levelSpace, deadline, interrupt)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfreeSpace = holder.getFreeSpace();\n\t\t}\n\n\t\treturn new LAFFResult(containerProducts, holder);\n\t}\n"}
{"Smelly Sample":"\t/**\n\t * Return a container which holds all the boxes in the argument\n\t *\n\t * @param boxes      list of boxes to fit in a container\n\t * @param containers list of containers\n\t * @param deadline   the system time in milliseconds at which the search should be aborted\n\t * @return index of container if match, -1 if not\n\t */\n\tpublic Container pack(List<BoxItem> boxes, List<Container> containers, long deadline) {\n\t\tif (containers.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tAdapter pack = adapter();\n\t\tpack.initialize(boxes, containers);\n\n\t\tif (!binarySearch || containers.size() <= 2 || deadline == Long.MAX_VALUE) {\n\t\t\tfor (int i = 0; i < containers.size(); i++) {\n\n\t\t\t\tif (System.currentTimeMillis() > deadline) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPackResult result = pack.attempt(i, deadline);\n\t\t\t\tif (result == null) {\n\t\t\t\t\treturn null; // timeout\n\t\t\t\t}\n\n\t\t\t\tif (!pack.hasMore(result)) {\n\t\t\t\t\treturn pack.accepted(result);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// perform a binary search among the available containers\n\t\t\t// the list is ranked from most desirable to least.\n\t\t\tPackResult[] results = new PackResult[containers.size()];\n\t\t\tboolean[] checked = new boolean[results.length];\n\n\t\t\tArrayList<Integer> containerIndexes = new ArrayList<>(containers.size());\n\t\t\tfor (int i = 0; i < containers.size(); i++) {\n\t\t\t\tcontainerIndexes.add(i);\n\t\t\t}\n\n\t\t\tBinarySearchIterator iterator = new BinarySearchIterator();\n\n\t\t\tsearch:\n\t\t\tdo {\n\t\t\t\titerator.reset(containerIndexes.size() - 1, 0);\n\n\t\t\t\tdo {\n\t\t\t\t\tint next = iterator.next();\n\t\t\t\t\tint mid = containerIndexes.get(next);\n\n\t\t\t\t\tPackResult result = pack.attempt(mid, deadline);\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\treturn null; // timeout\n\t\t\t\t\t}\n\t\t\t\t\tchecked[mid] = true;\n\t\t\t\t\tif (!pack.hasMore(result)) {\n\t\t\t\t\t\tresults[mid] = result;\n\n\t\t\t\t\t\titerator.lower();\n\t\t\t\t\t} else {\n\t\t\t\t\t\titerator.higher();\n\t\t\t\t\t}\n\t\t\t\t\tif (System.currentTimeMillis() > deadline) {\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t} while (iterator.hasNext());\n\n\t\t\t\t// halt when have a result, and checked all containers at the lower indexes\n\t\t\t\tfor (int i = 0; i < containerIndexes.size(); i++) {\n\t\t\t\t\tInteger integer = containerIndexes.get(i);\n\t\t\t\t\tif (results[integer] != null) {\n\t\t\t\t\t\t// remove end items; we already have a better match\n\t\t\t\t\t\twhile (containerIndexes.size() > i) {\n\t\t\t\t\t\t\tcontainerIndexes.remove(containerIndexes.size() - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// remove item\n\t\t\t\t\tif (checked[integer]) {\n\t\t\t\t\t\tcontainerIndexes.remove(i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!containerIndexes.isEmpty());\n\n\t\t\tfor (final PackResult result : results) {\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn pack.accepted(result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n","Method after Refactoring":"\t/**\n\t * Return a container which holds all the boxes in the argument\n\t *\n\t * @param boxes      list of boxes to fit in a container\n\t * @param containers list of containers\n\t * @param deadline   the system time in milliseconds at which the search should be aborted\n\t * @return index of container if match, -1 if not\n\t */\n\tpublic Container pack(List<BoxItem> boxes, List<Container> containers, long deadline) {\n\t\treturn pack(boxes, containers, deadline, new AtomicBoolean(false));\n\t}\n","Extracted Method":"\t/**\n\t * Return a container which holds all the boxes in the argument\n\t *\n\t * @param boxes      list of boxes to fit in a container\n\t * @param containers list of containers\n\t * @param deadline   the system time in milliseconds at which the search should be aborted\n\t * @param interrupt  if true, the computation will be interrupted as soon as possible.\n\t * @return index of container if match, -1 if not\n\t */\n\tpublic Container pack(List<BoxItem> boxes, List<Container> containers, long deadline, AtomicBoolean interrupt) {\n\t\tif (containers.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tAdapter pack = adapter();\n\t\tpack.initialize(boxes, containers);\n\n\t\tif (!binarySearch || containers.size() <= 2 || deadline == Long.MAX_VALUE) {\n\t\t\tfor (int i = 0; i < containers.size(); i++) {\n\n\t\t\t\tif (System.currentTimeMillis() > deadline || interrupt.get()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tPackResult result = pack.attempt(i, deadline);\n\t\t\t\tif (result == null) {\n\t\t\t\t\treturn null; // timeout\n\t\t\t\t}\n\n\t\t\t\tif (!pack.hasMore(result)) {\n\t\t\t\t\treturn pack.accepted(result);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// perform a binary search among the available containers\n\t\t\t// the list is ranked from most desirable to least.\n\t\t\tPackResult[] results = new PackResult[containers.size()];\n\t\t\tboolean[] checked = new boolean[results.length];\n\n\t\t\tArrayList<Integer> containerIndexes = new ArrayList<>(containers.size());\n\t\t\tfor (int i = 0; i < containers.size(); i++) {\n\t\t\t\tcontainerIndexes.add(i);\n\t\t\t}\n\n\t\t\tBinarySearchIterator iterator = new BinarySearchIterator();\n\n\t\t\tsearch:\n\t\t\tdo {\n\t\t\t\titerator.reset(containerIndexes.size() - 1, 0);\n\n\t\t\t\tdo {\n\t\t\t\t\tint next = iterator.next();\n\t\t\t\t\tint mid = containerIndexes.get(next);\n\n\t\t\t\t\tPackResult result = pack.attempt(mid, deadline);\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\treturn null; // timeout\n\t\t\t\t\t}\n\t\t\t\t\tchecked[mid] = true;\n\t\t\t\t\tif (!pack.hasMore(result)) {\n\t\t\t\t\t\tresults[mid] = result;\n\n\t\t\t\t\t\titerator.lower();\n\t\t\t\t\t} else {\n\t\t\t\t\t\titerator.higher();\n\t\t\t\t\t}\n\t\t\t\t\tif (System.currentTimeMillis() > deadline || interrupt.get()) {\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t} while (iterator.hasNext());\n\n\t\t\t\t// halt when have a result, and checked all containers at the lower indexes\n\t\t\t\tfor (int i = 0; i < containerIndexes.size(); i++) {\n\t\t\t\t\tInteger integer = containerIndexes.get(i);\n\t\t\t\t\tif (results[integer] != null) {\n\t\t\t\t\t\t// remove end items; we already have a better match\n\t\t\t\t\t\twhile (containerIndexes.size() > i) {\n\t\t\t\t\t\t\tcontainerIndexes.remove(containerIndexes.size() - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// remove item\n\t\t\t\t\tif (checked[integer]) {\n\t\t\t\t\t\tcontainerIndexes.remove(i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (!containerIndexes.isEmpty());\n\n\t\t\tfor (final PackResult result : results) {\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn pack.accepted(result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n"}
{"Smelly Sample":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @param deadline the system time in millis at which the search should be aborted\n\t * @return index of container if match, -1 if not\n\t */\n\t\n\tpublic Container pack(List<BoxItem> boxes, long deadline) {\n\t\treturn pack(boxes, filterContainers(boxes), deadline);\n\t}\n","Method after Refactoring":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @param deadline the system time in millis at which the search should be aborted\n\t * @return index of container if match, -1 if not\n\t */\n\t\n\tpublic Container pack(List<BoxItem> boxes, long deadline) {\n\t\treturn pack(boxes, filterByVolume(boxes, 1), deadline);\n\t}\n","Extracted Method":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @param limit maximum number of containers\n\t * @param deadline the system time in millis at which the search should be aborted\n\t * @return index of container if match, -1 if not\n\t */\n\t\n\tpublic Container pack(List<BoxItem> boxes, int limit, long deadline) {\n\t\treturn pack(boxes, filterByVolume(boxes, limit), deadline);\n\t}\n"}
{"Smelly Sample":"\t/**\n\t * Return a list of containers which can potentially hold the boxes.\n\t * \n\t * @param boxes list of boxes\n\t * @return list of containers\n\t */\n\t\n\tpublic List<Dimension> filterContainers(List<BoxItem> boxes) {\n\t\tlong volume = 0;\n\t\tfor(BoxItem box : boxes) {\n\t\t\tvolume += box.getBox().getVolume() * box.getCount();\n\t\t}\n\t\t\n\t\tList<Dimension> list = new ArrayList<>();\n\t\tfor(Dimension container : containers) {\n\t\t\tif(container.getVolume() < volume || !canHold(container, boxes)) {\n\t\t\t\t// discard this container\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlist.add(container);\n\t\t}\n\t\t\n\t\treturn list;\n\t}\n","Method after Refactoring":"\t/**\n\t * Return a list of containers which can potentially hold the boxes.\n\t * \n\t * @param boxes list of boxes\n\t * @return list of containers\n\t */\n\t\n\tpublic List<Container> filterByVolume(List<BoxItem> boxes, int count) {\n\t\tlong maxVolume = Long.MIN_VALUE;\n\t\tlong volume = 0;\n\t\tlong minVolume = Long.MAX_VALUE;\n\t\tfor(BoxItem box : boxes) {\n\t\t\tlong boxVolume = box.getBox().getVolume();\n\t\t\tvolume += boxVolume * box.getCount();\n\t\t\t\n\t\t\tif(boxVolume < minVolume) {\n\t\t\t\tminVolume = boxVolume;\n\t\t\t}\n\t\t\tif(volume > maxVolume) {\n\t\t\t\tmaxVolume = volume;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(maxVolume * count < volume) {\n\t\t\t// no containers will work at current count\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\t\n\t\tList<Container> list = new ArrayList<>();\n\t\tfor(Container container : containers) {\n\t\t\tif(container.getVolume() < minVolume) {\n\t\t\t\t// this box cannot even fit a single box\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(container.getVolume() + maxVolume * (count - 1) < volume) {\n\t\t\t\t// this box cannot be used even together with all biggest boxes\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(count == 1) {\n\t\t\t\tif(!canHoldAll(container, boxes)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(!canHoldAtLeastOne(container, boxes)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\n\t\t\tlist.add(container);\n\t\t}\n\t\t\n\t\treturn list;\n\t}\n","Extracted Method":"\tprotected boolean canHoldAtLeastOne(Dimension containerBox, List<BoxItem> boxes) {\n\t\tfor(BoxItem box : boxes) {\n\t\t\tif(rotate3D) {\n\t\t\t\tif(containerBox.canHold3D(box.getBox())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(containerBox.canHold2D(box.getBox())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n"}
{"Smelly Sample":"\tpublic Container pack(List<Box> boxes, long deadline) {\n\n\t\t// instead of placing boxes, work with placements\n\t\t// this very much reduces the number of objects created\n\t\t// performance gain is something like 25% over the box-centric approach\n\t\t\n\t\t// each box will at most have a single placement with a space (and its remainder). \n\t\tList<Placement> placements = new ArrayList<Placement>(boxes.size());\n\n\t\tlong volume = 0;\n\t\tfor(Box box : boxes) {\n\t\t\tvolume += box.getVolume();\n\t\t\t\n\t\t\tSpace a = new Space();\n\t\t\tSpace b = new Space();\n\t\t\ta.setRemainder(b);\n\t\t\tb.setRemainder(a);\n\t\t\t\n\t\t\tplacements.add(new Placement(a, box));\n\t\t}\n\t\t\n\t\tfor(Dimension container : containers) {\n\t\t\tif(System.currentTimeMillis() > deadline) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(container.getVolume() < volume || !canHold(container, boxes)) {\n\t\t\t\t// discard this container\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tContainer result = pack(placements, container, deadline);\n\t\t\tif(result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\t\t\n","Method after Refactoring":"\tpublic Container pack(List<Box> boxes, List<Dimension> dimensions, long deadline) {\n\n\t\t// instead of placing boxes, work with placements\n\t\t// this very much reduces the number of objects created\n\t\t// performance gain is something like 25% over the box-centric approach\n\n\t\tBox[][] rotations = PermutationRotationIterator.toRotationMatrix(boxes, rotate3D);\n\n\t\tList<Placement> placements = getPlacements(boxes.size());\n\t\t\n\t\tfor (int i = 0; i < dimensions.size(); i++) {\n\t\t\tif(System.currentTimeMillis() > deadline) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tContainer result = pack(placements, dimensions.get(i), rotations, deadline);\n\t\t\tif(result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n","Extracted Method":"\tpublic static List<Placement> getPlacements(int size) {\n\t\t// each box will at most have a single placement with a space (and its remainder). \n\t\tList<Placement> placements = new ArrayList<Placement>(size);\n\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tSpace a = new Space();\n\t\t\tSpace b = new Space();\n\t\t\ta.setRemainder(b);\n\t\t\tb.setRemainder(a);\n\t\t\t\n\t\t\tplacements.add(new Placement(a));\n\t\t}\n\t\treturn placements;\n\t}\t\t\n"}
{"Smelly Sample":"\tprotected Container pack(List<Placement> placements, Dimension container, long deadline) {\n\t\t\n\t\t// setup reusable objects\n\t\tint[] reset = new int[placements.size()];\n\n\t\tContainer holder = new Container(container);\n\n\t\tList<Placement> containerPlacements = new ArrayList<Placement>(placements.size());\n\n\t\tint[] rotations = new int[placements.size()];\n\n\t\tDimension remainingSpace = container;\n\t\t\n\t\t// iterator over all permutations\n\t\tPermutationIterator<Placement> iterator = new PermutationIterator<Placement>(placements);\n\t\twhile(iterator.hasNext()) {\n\t\t\tif(System.currentTimeMillis() > deadline) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tList<Placement> permutation = iterator.next();\n\n\t\t\t// for each permutation, try all combinations of rotation\n\t\t\tpermutation:\n\t\t\t\twhile(true) {\n\t\t\t\t\tfit: {\n\t\t\t\t\t\t// check sanity of current rotation\n\t\t\t\t\t\tfor(Placement placement : permutation) {\n\t\t\t\t\t\t\tif(!placement.getBox().fitsInside3D(remainingSpace)) {\n\t\t\t\t\t\t\t\tbreak fit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontainerPlacements.addAll(permutation);\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile(!containerPlacements.isEmpty()) {\n\t\t\t\t\t\t\tif(System.currentTimeMillis() > deadline) {\n\t\t\t\t\t\t\t\t// fit2d below might have returned due to deadline\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tPlacement placement = containerPlacements.remove(0);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(!placement.getBox().fitsInside3D(remainingSpace)) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// clean up\n\t\t\t\t\t\t\t\tholder.clear();\n\t\t\t\t\t\t\t\tcontainerPlacements.clear();\n\t\n\t\t\t\t\t\t\t\tbreak fit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tSpace levelSpace = placement.getSpace();\n\t\t\t\t\t\t\tlevelSpace.width = container.getWidth();\n\t\t\t\t\t\t\tlevelSpace.depth = container.getDepth();\n\t\t\t\t\t\t\tlevelSpace.height = placement.getBox().getHeight();\n\t\t\t\t\t\t\tlevelSpace.x = 0;\n\t\t\t\t\t\t\tlevelSpace.y = 0;\n\t\t\t\t\t\t\tlevelSpace.z = holder.getStackHeight();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tlevelSpace.setParent(null);\n\t\t\t\t\t\t\tlevelSpace.getRemainder().setParent(null);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tholder.addLevel();\n\n\t\t\t\t\t\t\t// update remaining space\n\t\t\t\t\t\t\tremainingSpace = holder.getRemainigFreeSpace();\n\n\t\t\t\t\t\t\tfit2D(containerPlacements, holder, placement, deadline);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn holder; // uncomment this line to run all combinations\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// find the next rotation\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// next rotation\n\t\t\t\t\t\tint index = rotate(rotations);\n\t\t\t\t\t\tif(index == -1) {\n\t\t\t\t\t\t\t// done\n\t\t\t\t\t\t\tbreak permutation;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tBox box = permutation.get(index).getBox();\n\t\t\t\t\t\tif(rotations[index] % 2 == 0) {\n\t\t\t\t\t\t\tif(box.isSquare2D()) {\n\t\t\t\t\t\t\t\t// skip 2d rotation\n\t\t\t\t\t\t\t\trotations[index]++;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbox.rotate2D();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(box.isSquare3D()) {\n\t\t\t\t\t\t\t\t// skip 2d and 3d rotations\n\t\t\t\t\t\t\t\trotations[index] = 6; \n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(box.isSquare2D()) {\n\t\t\t\t\t\t\t\tbox.rotate3D();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbox.rotate2D3D();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} while(true);\n\t\t\t\t}\n\t\t\t\n\t\t\t// clean up\n\t\t\t// reset rotation array\n\t\t\tSystem.arraycopy(reset, 0, rotations, 0, rotations.length);\n\t\t}\n\t\treturn null;\n\t}\t\n","Method after Refactoring":"\tprotected Container pack(List<Placement> placements, Dimension dimension, Box[][] rotations, long deadline) {\n\t\t\n\t\tPermutationRotationIterator rotator = new PermutationRotationIterator(dimension, rotations);\n\n\t\treturn pack(placements, dimension, rotator, deadline);\n\t}\n","Extracted Method":"\tpublic Container pack(List<Placement> placements, Dimension container, PermutationRotationIterator rotator, long deadline) {\n\t\t\n\t\tContainer holder = new Container(container);\n\n\t\t// iterator over all permutations\n\t\tdo {\n\t\t\tif(System.currentTimeMillis() > deadline) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// iterator over all rotations\n\t\t\t\n\t\t\tfit:\n\t\t\tdo {\n\t\t\t\tDimension remainingSpace = container;\n\n\t\t\t\tint index = 0;\n\t\t\t\twhile(index < rotator.length()) {\n\t\t\t\t\tif(System.currentTimeMillis() > deadline) {\n\t\t\t\t\t\t// fit2d below might have returned due to deadline\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!rotator.isWithinHeight(index, remainingSpace.getHeight())) {\n\t\t\t\t\t\t// clean up\n\t\t\t\t\t\tholder.clear();\n\t\t\t\t\t\t\n\t\t\t\t\t\tcontinue fit;\n\t\t\t\t\t}\n\n\t\t\t\t\tBox box = rotator.get(index);\n\t\t\t\t\t\n\t\t\t\t\tPlacement placement = placements.get(index);\n\t\t\t\t\tSpace levelSpace = placement.getSpace();\n\t\t\t\t\tlevelSpace.width = container.getWidth();\n\t\t\t\t\tlevelSpace.depth = container.getDepth();\n\t\t\t\t\tlevelSpace.height = box.getHeight();\n\t\t\t\t\t\n\t\t\t\t\tplacement.setBox(box);\n\t\t\t\t\t\n\t\t\t\t\tlevelSpace.x = 0;\n\t\t\t\t\tlevelSpace.y = 0;\n\t\t\t\t\tlevelSpace.z = holder.getStackHeight();\n\t\t\t\t\t\n\t\t\t\t\tlevelSpace.setParent(null);\n\t\t\t\t\tlevelSpace.getRemainder().setParent(null);\n\t\t\t\t\t\n\t\t\t\t\tholder.addLevel();\n\n\t\t\t\t\tindex++;\n\t\t\t\t\t\n\t\t\t\t\tindex = fit2D(rotator, index, placements, holder, placement, deadline);\n\t\t\t\t\t\n\t\t\t\t\t// update remaining space\n\t\t\t\t\tremainingSpace = holder.getRemainigFreeSpace();\n\t\t\t\t}\n\n\t\t\t\treturn holder;\n\t\t\t} while(rotator.nextRotation());\n\t\t} while(rotator.nextPermutation());\n\t\t\n\t\treturn null;\n\t}\t\n"}
{"Smelly Sample":"\tprotected boolean isFreespace(Space freespace, Box used, Placement target) {\n\n\t\t// Two free spaces, on each rotation of the used space. \n\t\t// Height is always the same, used box is assumed within free space height.\n\t\t// First:\n\t\t// ........................  ........................  .............\n\t\t// .                      .  .                      .  .           .\n\t\t// .                      .  .                      .  .           .\n\t\t// .          A           .  .          A           .  .           .\n\t\t// .                      .  .                      .  .           .\n\t\t// .                B     .  .                      .  .    B      .\n\t\t// ............           .  ........................  .           .\n\t\t// .          .           .                            .           .\n\t\t// .          .           .                            .           .\n\t\t// ........................                            .............\n        //\n\t\t// So there is always a 'big' and a 'small' leftover area (the small is not shown).\n\t\tif(freespace.getWidth() >= used.getWidth() && freespace.getDepth() >= used.getDepth()) {\n\t\t\t\n\t\t\t// if B is empty, then it is sufficient to work with A and the other way around\n\t\t\t\n\t\t\t// B\n\t\t\tif(freespace.getWidth() > used.getWidth()) {\n\t\t\t\t\n\t\t\t\tif(target.getBox().fitsInside3D(freespace.getWidth() - used.getWidth(), freespace.getDepth(), freespace.getHeight())) {\n\t\t\t\t\t// we have a winner\n\t\t\t\t\ttarget.getSpace().copyFrom(\n\t\t\t\t\t\t\tfreespace.getWidth() - used.getWidth(), freespace.getDepth(), freespace.getHeight(),\n\t\t\t\t\t\t\tfreespace.getX() + used.getWidth(), freespace.getY(), freespace.getZ()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\ttarget.getSpace().getRemainder().copyFrom(\n\t\t\t\t\t\t\tused.getWidth(), freespace.getDepth() - used.getDepth(), freespace.getHeight(),\n\t\t\t\t\t\t\tfreespace.getX(), freespace.getY()+ used.getDepth(), freespace.getZ()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\ttarget.getSpace().setParent(freespace);\n\t\t\t\t\ttarget.getSpace().getRemainder().setParent(freespace);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// A\n\t\t\tif(freespace.getDepth() > used.getDepth()) {\n\t\t\t\t\n\t\t\t\tif(target.getBox().fitsInside3D(freespace.getWidth(), freespace.getDepth() - used.getDepth(), freespace.getHeight())) {\n\t\t\t\t\ttarget.getSpace().copyFrom(\n\t\t\t\t\t\t\tfreespace.getWidth(), freespace.getDepth() - used.getDepth(), freespace.getHeight(),\n\t\t\t\t\t\t\tfreespace.getX(), freespace.getY() + used.depth, freespace.getHeight()\n\t\t\t\t\t\t);\n\t\t\t\t\ttarget.getSpace().getRemainder().copyFrom(\n\t\t\t\t\t\t\tfreespace.getWidth() - used.getWidth(), used.getDepth(), freespace.getHeight(),\n\t\t\t\t\t\t\tfreespace.getX() + used.getWidth(), freespace.getY(), freespace.getZ()\n\t\t\t\t\t\t);\n\t\t\t\t\ttarget.getSpace().setParent(freespace);\n\t\t\t\t\ttarget.getSpace().getRemainder().setParent(freespace);\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","Method after Refactoring":"\tprotected boolean isFreespace(Space freespace, Box used, Placement target) {\n\n\t\t// Two free spaces, on each rotation of the used space. \n\t\t// Height is always the same, used box is assumed within free space height.\n\t\t// First:\n\t\t// ........................  ........................  .............\n\t\t// .                      .  .                      .  .           .\n\t\t// .                      .  .                      .  .           .\n\t\t// .          A           .  .          A           .  .           .\n\t\t// .                      .  .                      .  .           .\n\t\t// .                B     .  .                      .  .    B      .\n\t\t// ............           .  ........................  .           .\n\t\t// .          .           .                            .           .\n\t\t// .          .           .                            .           .\n\t\t// ........................                            .............\n        //\n\t\t// So there is always a 'big' and a 'small' leftover area (the small is not shown).\n\t\tif(freespace.getWidth() >= used.getWidth() && freespace.getDepth() >= used.getDepth()) {\n\t\t\t\n\t\t\t// if B is empty, then it is sufficient to work with A and the other way around\n\t\t\tint b = (freespace.getWidth() - used.getWidth()) * freespace.getDepth();\n\t\t\tint a = freespace.getWidth() * (freespace.getDepth() - used.getDepth());\n\t\t\t\n\t\t\t// pick the one with largest footprint.\n\t\t\tif(b >= a) {\n\t\t\t\tif(b > 0 && b(freespace, used, target)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn a > 0 && a(freespace, used, target);\n\t\t\t} else {\n\t\t\t\tif(a > 0 && a(freespace, used, target)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn b > 0 && b(freespace, used, target);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","Extracted Method":"\tprivate boolean a(Space freespace, Box used, Placement target) {\n\t\tif(target.getBox().fitsInside3D(freespace.getWidth(), freespace.getDepth() - used.getDepth(), freespace.getHeight())) {\n\t\t\ttarget.getSpace().copyFrom(\n\t\t\t\t\tfreespace.getWidth(), freespace.getDepth() - used.getDepth(), freespace.getHeight(),\n\t\t\t\t\tfreespace.getX(), freespace.getY() + used.depth, freespace.getHeight()\n\t\t\t\t);\n\t\t\ttarget.getSpace().getRemainder().copyFrom(\n\t\t\t\t\tfreespace.getWidth() - used.getWidth(), used.getDepth(), freespace.getHeight(),\n\t\t\t\t\tfreespace.getX() + used.getWidth(), freespace.getY(), freespace.getZ()\n\t\t\t\t);\n\t\t\ttarget.getSpace().setParent(freespace);\n\t\t\ttarget.getSpace().getRemainder().setParent(freespace);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n"}
{"Smelly Sample":"\tprotected boolean isFreespace(Space freespace, Box used, Placement target) {\n\n\t\t// Two free spaces, on each rotation of the used space. \n\t\t// Height is always the same, used box is assumed within free space height.\n\t\t// First:\n\t\t// ........................  ........................  .............\n\t\t// .                      .  .                      .  .           .\n\t\t// .                      .  .                      .  .           .\n\t\t// .          A           .  .          A           .  .           .\n\t\t// .                      .  .                      .  .           .\n\t\t// .                B     .  .                      .  .    B      .\n\t\t// ............           .  ........................  .           .\n\t\t// .          .           .                            .           .\n\t\t// .          .           .                            .           .\n\t\t// ........................                            .............\n        //\n\t\t// So there is always a 'big' and a 'small' leftover area (the small is not shown).\n\t\tif(freespace.getWidth() >= used.getWidth() && freespace.getDepth() >= used.getDepth()) {\n\t\t\t\n\t\t\t// if B is empty, then it is sufficient to work with A and the other way around\n\t\t\t\n\t\t\t// B\n\t\t\tif(freespace.getWidth() > used.getWidth()) {\n\t\t\t\t\n\t\t\t\tif(target.getBox().fitsInside3D(freespace.getWidth() - used.getWidth(), freespace.getDepth(), freespace.getHeight())) {\n\t\t\t\t\t// we have a winner\n\t\t\t\t\ttarget.getSpace().copyFrom(\n\t\t\t\t\t\t\tfreespace.getWidth() - used.getWidth(), freespace.getDepth(), freespace.getHeight(),\n\t\t\t\t\t\t\tfreespace.getX() + used.getWidth(), freespace.getY(), freespace.getZ()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\ttarget.getSpace().getRemainder().copyFrom(\n\t\t\t\t\t\t\tused.getWidth(), freespace.getDepth() - used.getDepth(), freespace.getHeight(),\n\t\t\t\t\t\t\tfreespace.getX(), freespace.getY()+ used.getDepth(), freespace.getZ()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\ttarget.getSpace().setParent(freespace);\n\t\t\t\t\ttarget.getSpace().getRemainder().setParent(freespace);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// A\n\t\t\tif(freespace.getDepth() > used.getDepth()) {\n\t\t\t\t\n\t\t\t\tif(target.getBox().fitsInside3D(freespace.getWidth(), freespace.getDepth() - used.getDepth(), freespace.getHeight())) {\n\t\t\t\t\ttarget.getSpace().copyFrom(\n\t\t\t\t\t\t\tfreespace.getWidth(), freespace.getDepth() - used.getDepth(), freespace.getHeight(),\n\t\t\t\t\t\t\tfreespace.getX(), freespace.getY() + used.depth, freespace.getHeight()\n\t\t\t\t\t\t);\n\t\t\t\t\ttarget.getSpace().getRemainder().copyFrom(\n\t\t\t\t\t\t\tfreespace.getWidth() - used.getWidth(), used.getDepth(), freespace.getHeight(),\n\t\t\t\t\t\t\tfreespace.getX() + used.getWidth(), freespace.getY(), freespace.getZ()\n\t\t\t\t\t\t);\n\t\t\t\t\ttarget.getSpace().setParent(freespace);\n\t\t\t\t\ttarget.getSpace().getRemainder().setParent(freespace);\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","Method after Refactoring":"\tprotected boolean isFreespace(Space freespace, Box used, Placement target) {\n\n\t\t// Two free spaces, on each rotation of the used space. \n\t\t// Height is always the same, used box is assumed within free space height.\n\t\t// First:\n\t\t// ........................  ........................  .............\n\t\t// .                      .  .                      .  .           .\n\t\t// .                      .  .                      .  .           .\n\t\t// .          A           .  .          A           .  .           .\n\t\t// .                      .  .                      .  .           .\n\t\t// .                B     .  .                      .  .    B      .\n\t\t// ............           .  ........................  .           .\n\t\t// .          .           .                            .           .\n\t\t// .          .           .                            .           .\n\t\t// ........................                            .............\n        //\n\t\t// So there is always a 'big' and a 'small' leftover area (the small is not shown).\n\t\tif(freespace.getWidth() >= used.getWidth() && freespace.getDepth() >= used.getDepth()) {\n\t\t\t\n\t\t\t// if B is empty, then it is sufficient to work with A and the other way around\n\t\t\tint b = (freespace.getWidth() - used.getWidth()) * freespace.getDepth();\n\t\t\tint a = freespace.getWidth() * (freespace.getDepth() - used.getDepth());\n\t\t\t\n\t\t\t// pick the one with largest footprint.\n\t\t\tif(b >= a) {\n\t\t\t\tif(b > 0 && b(freespace, used, target)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn a > 0 && a(freespace, used, target);\n\t\t\t} else {\n\t\t\t\tif(a > 0 && a(freespace, used, target)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn b > 0 && b(freespace, used, target);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","Extracted Method":"\tprivate boolean b(Space freespace, Box used, Placement target) {\n\t\tif(target.getBox().fitsInside3D(freespace.getWidth() - used.getWidth(), freespace.getDepth(), freespace.getHeight())) {\n\t\t\t// we have a winner\n\t\t\ttarget.getSpace().copyFrom(\n\t\t\t\t\tfreespace.getWidth() - used.getWidth(), freespace.getDepth(), freespace.getHeight(),\n\t\t\t\t\tfreespace.getX() + used.getWidth(), freespace.getY(), freespace.getZ()\n\t\t\t\t\t);\n\t\t\t\n\t\t\ttarget.getSpace().getRemainder().copyFrom(\n\t\t\t\t\tused.getWidth(), freespace.getDepth() - used.getDepth(), freespace.getHeight(),\n\t\t\t\t\tfreespace.getX(), freespace.getY()+ used.getDepth(), freespace.getZ()\n\t\t\t\t\t);\n\t\t\t\n\t\t\ttarget.getSpace().setParent(freespace);\n\t\t\ttarget.getSpace().getRemainder().setParent(freespace);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n"}
{"Smelly Sample":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @return null if no match\n\t */\n\t\n\tpublic Container pack(List<Box> boxes) {\n\t\t\n\t\tlong volume = 0;\n\t\tfor(Box box : boxes) {\n\t\t\tvolume += box.getVolume();\n\t\t}\n\t\t\n\t\tboxes:\n\t\tfor(Dimension containerBox : containers) {\n\t\t\tif(containerBox.getVolume() < volume || !canHold(containerBox, boxes)) {\n\t\t\t\t// discard this container\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tList<Box> containerProducts = new ArrayList<Box>(boxes);\n\t\t\t\n\t\t\tContainer holder = new Container(containerBox);\n\t\t\t\n\t\t\twhile(!containerProducts.isEmpty()) {\n\t\t\t\t// choose the box with the largest surface area, that fits\n\t\t\t\t// if the same then the one with minimum height\n\t\t\t\tDimension space = holder.getRemainigFreeSpace();\n\t\t\t\tBox currentBox = null;\n\t\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\t\n\t\t\t\t\tboolean fits;\n\t\t\t\t\tif(rotate3D) {\n\t\t\t\t\t\tfits = box.rotateLargestFootprint3D(space);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfits = box.fitRotate2D(space);\n\t\t\t\t\t}\n\t\t\t\t\tif(fits) {\n\t\t\t\t\t\tif(currentBox == null) {\n\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(footprintFirst) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t} else if(currentBox.getFootprint() == box.getFootprint() && currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t} else if(currentBox.getHeight() == box.getHeight() && currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// no fit in the current container within the remaining space\n\t\t\t\t\t\t// try the next container\n\n\t\t\t\t\t\tcontinue boxes;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(currentBox.getHeight() < space.getHeight()) {\n\t\t\t\t\t// see whether we can get a fit for full height\n\t\t\t\t\tBox idealBox = null;\n\t\t\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\t\tif(box.getHeight() == space.getHeight()) {\n\t\t\t\t\t\t\tif(idealBox == null) {\n\t\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t\t} else if(idealBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(idealBox != null) {\n\t\t\t\t\t\tcurrentBox = idealBox;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\t// current box should have the optimal orientation already\n\t\t\t\t// create a space which holds the full level\n\t\t\t\tSpace levelSpace = new Space(\n\t\t\t\t\t\t\tcontainerBox.getWidth(), \n\t\t\t\t\t\t\tcontainerBox.getDepth(), \n\t\t\t\t\t\t\tcurrentBox.getHeight(), \n\t\t\t\t\t\t\t0, \n\t\t\t\t\t\t\t0, \n\t\t\t\t\t\t\tholder.getStackHeight()\n\t\t\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\tholder.addLevel();\n\t\t\t\tremoveIdentical(containerProducts, currentBox);\n\n\t\t\t\tfit2D(containerProducts, holder, currentBox, levelSpace);\n\t\t\t}\n\n\t\t\treturn holder;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n","Method after Refactoring":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @return null if no match\n\t */\n\t\n\tpublic Container pack(List<Box> boxes, long timeout) {\n\t\t\n\t\tlong volume = 0;\n\t\tfor(Box box : boxes) {\n\t\t\tvolume += box.getVolume();\n\t\t}\n\t\t\n\t\tfor(Dimension containerBox : containers) {\n\t\t\tif(System.currentTimeMillis() > timeout) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(containerBox.getVolume() < volume || !canHold(containerBox, boxes)) {\n\t\t\t\t// discard this container\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tContainer result = pack(boxes, containerBox, timeout);\n\t\t\tif(result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\t\n","Extracted Method":"\tprotected Container pack(List<Box> boxes, Dimension containerBox, long timeout) {\n\t\tList<Box> containerProducts = new ArrayList<Box>(boxes);\n\t\t\n\t\tContainer holder = new Container(containerBox);\n\t\t\n\t\twhile(!containerProducts.isEmpty()) {\n\t\t\tif(System.currentTimeMillis() > timeout) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// choose the box with the largest surface area, that fits\n\t\t\t// if the same then the one with minimum height\n\t\t\tDimension space = holder.getRemainigFreeSpace();\n\t\t\tBox currentBox = null;\n\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\n\t\t\t\tboolean fits;\n\t\t\t\tif(rotate3D) {\n\t\t\t\t\tfits = box.rotateLargestFootprint3D(space);\n\t\t\t\t} else {\n\t\t\t\t\tfits = box.fitRotate2D(space);\n\t\t\t\t}\n\t\t\t\tif(fits) {\n\t\t\t\t\tif(currentBox == null) {\n\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(footprintFirst) {\n\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t} else if(currentBox.getFootprint() == box.getFootprint() && currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t} else if(currentBox.getHeight() == box.getHeight() && currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// no fit in the current container within the remaining space\n\t\t\t\t\t// try the next container\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(currentBox.getHeight() < space.getHeight()) {\n\t\t\t\t// see whether we can get a fit for full height\n\t\t\t\tBox idealBox = null;\n\t\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\tif(box.getHeight() == space.getHeight()) {\n\t\t\t\t\t\tif(idealBox == null) {\n\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t} else if(idealBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(idealBox != null) {\n\t\t\t\t\tcurrentBox = idealBox;\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\t\t\t\n\t\t\t// current box should have the optimal orientation already\n\t\t\t// create a space which holds the full level\n\t\t\tSpace levelSpace = new Space(\n\t\t\t\t\t\tcontainerBox.getWidth(), \n\t\t\t\t\t\tcontainerBox.getDepth(), \n\t\t\t\t\t\tcurrentBox.getHeight(), \n\t\t\t\t\t\t0, \n\t\t\t\t\t\t0, \n\t\t\t\t\t\tholder.getStackHeight()\n\t\t\t\t\t\t);\n\t\t\t\n\t\t\tholder.addLevel();\n\t\t\tremoveIdentical(containerProducts, currentBox);\n\n\t\t\tfit2D(containerProducts, holder, currentBox, levelSpace, timeout);\n\t\t}\n\t\t\n\t\treturn holder;\n\t}\n"}
{"Smelly Sample":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @return null if no match\n\t */\n\t\n\tpublic Container pack(List<Box> boxes) {\n\t\t\n\t\tlong volume = 0;\n\t\tfor(Box box : boxes) {\n\t\t\tvolume += box.getVolume();\n\t\t}\n\t\t\n\t\tboxes:\n\t\tfor(Dimension containerBox : containers) {\n\t\t\tif(containerBox.getVolume() < volume || !canHold(containerBox, boxes)) {\n\t\t\t\t// discard this container\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tList<Box> containerProducts = new ArrayList<Box>(boxes);\n\t\t\t\n\t\t\tContainer holder = new Container(containerBox);\n\t\t\t\n\t\t\twhile(!containerProducts.isEmpty()) {\n\t\t\t\t// choose the box with the largest surface area, that fits\n\t\t\t\t// if the same then the one with minimum height\n\t\t\t\tDimension space = holder.getRemainigFreeSpace();\n\t\t\t\tBox currentBox = null;\n\t\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\t\n\t\t\t\t\tboolean fits;\n\t\t\t\t\tif(rotate3D) {\n\t\t\t\t\t\tfits = box.rotateLargestFootprint3D(space);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfits = box.fitRotate2D(space);\n\t\t\t\t\t}\n\t\t\t\t\tif(fits) {\n\t\t\t\t\t\tif(currentBox == null) {\n\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(footprintFirst) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t} else if(currentBox.getFootprint() == box.getFootprint() && currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t} else if(currentBox.getHeight() == box.getHeight() && currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// no fit in the current container within the remaining space\n\t\t\t\t\t\t// try the next container\n\n\t\t\t\t\t\tcontinue boxes;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(currentBox.getHeight() < space.getHeight()) {\n\t\t\t\t\t// see whether we can get a fit for full height\n\t\t\t\t\tBox idealBox = null;\n\t\t\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\t\tif(box.getHeight() == space.getHeight()) {\n\t\t\t\t\t\t\tif(idealBox == null) {\n\t\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t\t} else if(idealBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(idealBox != null) {\n\t\t\t\t\t\tcurrentBox = idealBox;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\t// current box should have the optimal orientation already\n\t\t\t\t// create a space which holds the full level\n\t\t\t\tSpace levelSpace = new Space(\n\t\t\t\t\t\t\tcontainerBox.getWidth(), \n\t\t\t\t\t\t\tcontainerBox.getDepth(), \n\t\t\t\t\t\t\tcurrentBox.getHeight(), \n\t\t\t\t\t\t\t0, \n\t\t\t\t\t\t\t0, \n\t\t\t\t\t\t\tholder.getStackHeight()\n\t\t\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\tholder.addLevel();\n\t\t\t\tremoveIdentical(containerProducts, currentBox);\n\n\t\t\t\tfit2D(containerProducts, holder, currentBox, levelSpace);\n\t\t\t}\n\n\t\t\treturn holder;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n","Method after Refactoring":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @return null if no match\n\t */\n\t\n\tpublic Container pack(List<Box> boxes) {\n\t\treturn pack(boxes, Long.MAX_VALUE);\n\t}\n","Extracted Method":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @return null if no match\n\t */\n\t\n\tpublic Container pack(List<Box> boxes, long timeout) {\n\t\t\n\t\tlong volume = 0;\n\t\tfor(Box box : boxes) {\n\t\t\tvolume += box.getVolume();\n\t\t}\n\t\t\n\t\tfor(Dimension containerBox : containers) {\n\t\t\tif(System.currentTimeMillis() > timeout) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(containerBox.getVolume() < volume || !canHold(containerBox, boxes)) {\n\t\t\t\t// discard this container\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tContainer result = pack(boxes, containerBox, timeout);\n\t\t\tif(result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\t\n"}
{"Smelly Sample":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @return null if no match\n\t */\n\t\n\tpublic Container pack(List<Box> boxes) {\n\t\t\n\t\tint volume = 0;\n\t\tfor(Box box : boxes) {\n\t\t\tvolume += box.getVolume();\n\t\t}\n\t\t\n\t\tboxes:\n\t\tfor(Dimension containerBox : containers) {\n\t\t\tif(containerBox.getVolume() < volume) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(Box box : boxes) {\n\t\t\t\tif(rotate3D) {\n\t\t\t\t\tif(!containerBox.canHold3D(box)) {\n\t\t\t\t\t\tcontinue boxes;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(!containerBox.canHold2D(box)) {\n\t\t\t\t\t\tcontinue boxes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tList<Box> containerProducts = new ArrayList<Box>(boxes);\n\t\t\t\n\t\t\tContainer holder = new Container(containerBox);\n\t\t\t\n\t\t\twhile(!containerProducts.isEmpty()) {\n\t\t\t\t// choose the box with the largest surface area, that fits\n\t\t\t\t// if the same then the one with minimum height\n\t\t\t\tDimension space = holder.getRemainigFreeSpace();\n\t\t\t\tBox currentBox = null;\n\t\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\t\n\t\t\t\t\tboolean fits;\n\t\t\t\t\tif(rotate3D) {\n\t\t\t\t\t\tfits = box.rotateLargestFootprint3D(space);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfits = box.fitRotate2D(space);\n\t\t\t\t\t}\n\t\t\t\t\tif(fits) {\n\t\t\t\t\t\tif(currentBox == null) {\n\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(footprintFirst) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t} else if(currentBox.getFootprint() == box.getFootprint() && currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t} else if(currentBox.getHeight() == box.getHeight() && currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// no fit in the current container within the remaining space\n\t\t\t\t\t\t// try the next container\n\n\t\t\t\t\t\tcontinue boxes;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(currentBox.getHeight() < space.getHeight()) {\n\t\t\t\t\t// see whether we can get a fit for full height\n\t\t\t\t\tBox idealBox = null;\n\t\t\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\t\tif(box.getHeight() == space.getHeight()) {\n\t\t\t\t\t\t\tif(idealBox == null) {\n\t\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t\t} else if(idealBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(idealBox != null) {\n\t\t\t\t\t\tcurrentBox = idealBox;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\t// current box should have the optimal orientation already\n\t\t\t\t// create a space which holds the full level\n\t\t\t\tSpace levelSpace = new Space(\n\t\t\t\t\t\t\tcontainerBox.getWidth(), \n\t\t\t\t\t\t\tcontainerBox.getDepth(), \n\t\t\t\t\t\t\tcurrentBox.getHeight(), \n\t\t\t\t\t\t\t0, \n\t\t\t\t\t\t\t0, \n\t\t\t\t\t\t\tholder.getStackHeight()\n\t\t\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\tholder.addLevel();\n\t\t\t\tcontainerProducts.remove(currentBox);\n\n\t\t\t\tfit2D(containerProducts, holder, currentBox, levelSpace);\n\t\t\t}\n\n\t\t\treturn holder;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n","Method after Refactoring":"\t/**\n\t * \n\t * Return a container which holds all the boxes in the argument\n\t * \n\t * @param boxes list of boxes to fit in a container\n\t * @return null if no match\n\t */\n\t\n\tpublic Container pack(List<Box> boxes) {\n\t\t\n\t\tlong volume = 0;\n\t\tfor(Box box : boxes) {\n\t\t\tvolume += box.getVolume();\n\t\t}\n\t\t\n\t\tboxes:\n\t\tfor(Dimension containerBox : containers) {\n\t\t\tif(containerBox.getVolume() < volume || !canHold(containerBox, boxes)) {\n\t\t\t\t// discard this container\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tList<Box> containerProducts = new ArrayList<Box>(boxes);\n\t\t\t\n\t\t\tContainer holder = new Container(containerBox);\n\t\t\t\n\t\t\twhile(!containerProducts.isEmpty()) {\n\t\t\t\t// choose the box with the largest surface area, that fits\n\t\t\t\t// if the same then the one with minimum height\n\t\t\t\tDimension space = holder.getRemainigFreeSpace();\n\t\t\t\tBox currentBox = null;\n\t\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\t\n\t\t\t\t\tboolean fits;\n\t\t\t\t\tif(rotate3D) {\n\t\t\t\t\t\tfits = box.rotateLargestFootprint3D(space);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfits = box.fitRotate2D(space);\n\t\t\t\t\t}\n\t\t\t\t\tif(fits) {\n\t\t\t\t\t\tif(currentBox == null) {\n\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(footprintFirst) {\n\t\t\t\t\t\t\t\tif(currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t} else if(currentBox.getFootprint() == box.getFootprint() && currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(currentBox.getHeight() < box.getHeight()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t} else if(currentBox.getHeight() == box.getHeight() && currentBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\t\tcurrentBox = box;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// no fit in the current container within the remaining space\n\t\t\t\t\t\t// try the next container\n\n\t\t\t\t\t\tcontinue boxes;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(currentBox.getHeight() < space.getHeight()) {\n\t\t\t\t\t// see whether we can get a fit for full height\n\t\t\t\t\tBox idealBox = null;\n\t\t\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\t\tif(box.getHeight() == space.getHeight()) {\n\t\t\t\t\t\t\tif(idealBox == null) {\n\t\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t\t} else if(idealBox.getFootprint() < box.getFootprint()) {\n\t\t\t\t\t\t\t\tidealBox = box;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(idealBox != null) {\n\t\t\t\t\t\tcurrentBox = idealBox;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\t// current box should have the optimal orientation already\n\t\t\t\t// create a space which holds the full level\n\t\t\t\tSpace levelSpace = new Space(\n\t\t\t\t\t\t\tcontainerBox.getWidth(), \n\t\t\t\t\t\t\tcontainerBox.getDepth(), \n\t\t\t\t\t\t\tcurrentBox.getHeight(), \n\t\t\t\t\t\t\t0, \n\t\t\t\t\t\t\t0, \n\t\t\t\t\t\t\tholder.getStackHeight()\n\t\t\t\t\t\t\t);\n\t\t\t\t\n\t\t\t\tholder.addLevel();\n\t\t\t\tremoveIdentical(containerProducts, currentBox);\n\n\t\t\t\tfit2D(containerProducts, holder, currentBox, levelSpace);\n\t\t\t}\n\n\t\t\treturn holder;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n","Extracted Method":"\tprivate boolean canHold(Dimension containerBox, List<Box> boxes) {\n\t\tfor(Box box : boxes) {\n\t\t\tif(rotate3D) {\n\t\t\t\tif(!containerBox.canHold3D(box)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(!containerBox.canHold2D(box)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n"}
{"Smelly Sample":"\t/**\n\t * Constructor\n\t * \n\t * @param containers Dimensions of supported containers\n\t */\n\n\tpublic Packager(List<? extends Dimension> containers) {\n\t\tthis.containers = containers.toArray(new Dimension[containers.size()]);\n\t}\n","Method after Refactoring":"\t/**\n\t * Constructor\n\t * \n\t * @param containers Dimensions of supported containers\n\t */\n\tpublic Packager(List<? extends Dimension> containers) {\n\t\tthis(containers, true);\n\t}\n","Extracted Method":"\tpublic Packager(List<? extends Dimension> containers, boolean rotate3D) {\n\t\tthis.containers = containers.toArray(new Dimension[containers.size()]);\n\t\tthis.rotate3D = rotate3D;\n\t}\n"}
{"Smelly Sample":"\tprivate void fit(List<Box> containerProducts, Container holder, Box usedSpace, Dimension freespace) {\n\n\t\tList<Dimension> spaces = getFreespaces(freespace, usedSpace);\n\t\tif(spaces.isEmpty()) {\n\t\t\t// no boxes\n\t\t\treturn;\n\t\t} \n\t\tBox nextBox = bestVolume(containerProducts, spaces); // sets space as parent\n\n\t\tif(nextBox == null) {\n\t\t\t// no fit\n\t\t\treturn;\n\t\t}\n\t\tDimension space = nextBox.getParent();\n\t\t\n\t\tnextBox.rotateSmallestFootprint(space);\n\t\t\n\t\tholder.add(nextBox);\n\t\tcontainerProducts.remove(nextBox);\n\n\t\t// stack in leftover from original free space\n\t\tDimension remainder = space.getParent();\n\t\tif(!remainder.isEmpty()) {\n\t\t\tfitNext(containerProducts, holder, remainder);\n\t\t\tif(containerProducts.isEmpty()) {\n\t\t\t\t// finished\n\t\t\t\treturn;\n\t\t\t} \n\t\t}\n\t\t\n\t\t// determine stacking within free space to maximize leftover area\n\t\tList<Dimension> freeSpaces = getFreespaces(space, nextBox);\n\n\t\tif(freeSpaces.isEmpty()) {\n\t\t\t// no more space left\n\t\t\treturn;\n\t\t} \n\n\t\tDimension nextFreeSpace = null;\n\t\tfor(Dimension free : freeSpaces) {\n\t\t\tif(nextFreeSpace == null || free.getFootprint() > nextFreeSpace.getFootprint()) {\n\t\t\t\tnextFreeSpace = free;\n\t\t\t}\n\t\t}\n\t\t\n\t\tDimension nextFreeSpaceRemainder = nextFreeSpace.getParent();\n\t\t\n\t\tfitNext(containerProducts, holder, nextFreeSpace);\n\t\tif(containerProducts.isEmpty()) {\n\t\t\t// finished\n\t\t\treturn;\n\t\t} \n\t\t\n\t\tif(!nextFreeSpaceRemainder.isEmpty()) {\n\t\t\tfitNext(containerProducts, holder, nextFreeSpaceRemainder);\n\t\t}\n\t}\n","Method after Refactoring":"\tprivate void fitNext(List<Box> containerProducts, Container holder, Space freeSpace) {\n\t\tif(!freeSpace.isEmpty()) {\n\t\t\tPlacement placement = bestVolume(containerProducts, freeSpace);\n\t\t\t\n\t\t\tif(placement != null) {\n\t\t\t\tholder.add(placement);\n\t\t\t\tcontainerProducts.remove(placement.getBox());\n\t\t\t\t\n\t\t\t\tif(rotate3D) {\n\t\t\t\t\tplacement.getBox().fitRotate3DSmallestFootprint(freeSpace);\n\t\t\t\t}\n\t\t\t\tfit2D(containerProducts, holder, placement.getBox(), freeSpace);\n\t\t\t}\n\t\t}\n\t}\n","Extracted Method":"\tprivate void fit2D(List<Box> containerProducts, Container holder, Box usedSpace, Space freeSpace) {\n\n\t\tList<Space> spaces = getFreespaces(freeSpace, usedSpace);\n\t\tif(spaces.isEmpty()) {\n\t\t\t// no boxes\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tPlacement nextPlacement = bestVolume(containerProducts, spaces);\n\t\tif(nextPlacement == null) {\n\t\t\t// no fit\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(rotate3D) { // maximize use of height\n\t\t\tnextPlacement.getBox().fitRotate3DSmallestFootprint(nextPlacement.getSpace());\n\t\t} else {\n\t\t\tnextPlacement.getBox().fitRotate2D(nextPlacement.getSpace());\n\t\t}\n\t\t\n\t\tholder.add(nextPlacement);\n\t\tcontainerProducts.remove(nextPlacement.getBox());\n\n\t\t// stack in the 'sibling' space - other part of free space\n\t\tSpace remainder = (Space) nextPlacement.getSpace().getRemainder();\n\t\tif(!remainder.isEmpty()) {\n\t\t\tfitNext(containerProducts, holder, remainder);\n\t\t\tif(containerProducts.isEmpty()) {\n\t\t\t\t// finished\n\t\t\t\treturn;\n\t\t\t} \n\t\t}\n\t\t\n\t\t// determine if the stacking left some space over in the selected space\n\t\tList<Space> freeSpaces = getFreespaces(nextPlacement.getSpace(), nextPlacement.getBox());\n\n\t\tif(freeSpaces.isEmpty()) {\n\t\t\t// no more space left\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSpace nextFreeSpace = null;\n\t\tfor(Space free : freeSpaces) {\n\t\t\tif(nextFreeSpace == null || free.getFootprint() > nextFreeSpace.getFootprint()) {\n\t\t\t\tnextFreeSpace = free;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfitNext(containerProducts, holder, nextFreeSpace);\n\t\tif(containerProducts.isEmpty()) {\n\t\t\t// finished\n\t\t\treturn;\n\t\t} \n\t\t\n\t\tSpace nextFreeSpaceRemainder = nextFreeSpace.getRemainder();\n\t\tif(!nextFreeSpaceRemainder.isEmpty()) {\n\t\t\tfitNext(containerProducts, holder, nextFreeSpaceRemainder);\n\t\t}\n\t}\n"}
{"Smelly Sample":"\tprivate Box bestVolume(List<Box> containerProducts, List<Dimension> spaces) {\n\t\t\n\t\tBox best = null;\n\t\tfor(Dimension space : spaces) {\n\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\n\t\t\t\tif(box.canFitInside(space)) {\n\t\t\t\t\tif(best == null) {\n\t\t\t\t\t\tbest = box;\n\t\t\t\t\t\t\n\t\t\t\t\t\tbox.setParent(space);\n\t\t\t\t\t} else if(best.getVolume() < box.getVolume()) {\n\t\t\t\t\t\tbest = box;\n\t\t\t\t\t\t\n\t\t\t\t\t\tbox.setParent(space);\n\t\t\t\t\t} else if(best.getVolume() == box.getVolume()) {\n\t\t\t\t\t\t// determine lowest fit\n\t\t\t\t\t\tbest.rotateSmallestFootprint(space);\n\t\n\t\t\t\t\t\tbox.rotateSmallestFootprint(space);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(box.getFootprint() < best.getFootprint()) {\n\t\t\t\t\t\t\tbest = box;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbox.setParent(space);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn best;\n\t}\n","Method after Refactoring":"\tprivate Placement bestVolume(List<Box> containerProducts, Space space) {\n\t\treturn bestVolume(containerProducts, Arrays.asList(space));\n\t}\n","Extracted Method":"\tprivate Placement bestVolume(List<Box> containerProducts, List<Space> spaces) {\n\t\t\n\t\tBox bestBox = null;\n\t\tSpace bestSpace = null;\n\t\tfor(Space space : spaces) {\n\t\t\tfor(Box box : containerProducts) {\n\t\t\t\t\n\t\t\t\tif(rotate3D) {\n\t\t\t\t\tif(box.canFitInside3D(space)) {\n\t\t\t\t\t\tif(bestBox == null) {\n\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\tbestSpace = space;\n\t\t\t\t\t\t} else if(bestBox.getVolume() < box.getVolume()) {\n\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\tbestSpace = space;\n\t\t\t\t\t\t} else if(bestBox.getVolume() == box.getVolume()) {\n\t\t\t\t\t\t\t// determine lowest fit\n\t\t\t\t\t\t\tbestBox.fitRotate3DSmallestFootprint(space);\n\t\t\n\t\t\t\t\t\t\tbox.fitRotate3DSmallestFootprint(space);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(box.getFootprint() < bestBox.getFootprint()) {\n\t\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\t\tbestSpace = space;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(box.canFitInside2D(space)) {\n\t\t\t\t\t\tif(bestBox == null) {\n\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\tbestSpace = space;\n\t\t\t\t\t\t} else if(bestBox.getVolume() < box.getVolume()) {\n\t\t\t\t\t\t\tbestBox = box;\n\t\t\t\t\t\t\tbestSpace = space;\n\t\t\t\t\t\t} else if(bestBox.getVolume() < box.getVolume()) {\n\t\t\t\t\t\t\t// TODO use the aspect ratio in some meaningful way\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(bestBox != null) {\n\t\t\treturn new Placement(bestSpace, bestBox);\n\t\t}\n\t\treturn null;\n\t}\n"}
{"Smelly Sample":"\tpublic boolean rotateLargestFootprint(int w, int d, int h) {\n\t\tint a = -1;\n\t\tif(w >= width && h >= height && d >= depth) {\n\t\t\ta = width * depth;\n\t\t}\n\n\t\tint b = -1;\n\t\tif(h >= width && d >= height && w >= depth) {\n\t\t\tb = height * depth;\n\t\t}\n\n\t\tint c = -1;\n\t\tif(d >= width && w >= height && h >= depth) {\n\t\t\tc = width * height;\n\t\t}\n\t\t\n\t\tif(a == -1 && b == -1 && c == -1) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(a > b && a > c) {\n\t\t\t// no rotate\n\t\t} else if(b > c) {\n\t\t\t// rotate once\n\t\t\trotate3D();\n\t\t} else {\n\t\t\trotate3D();\n\t\t\trotate3D();\n\t\t}\n\n\t\treturn true;\n\t\t\n\t}\n","Method after Refactoring":"\tpublic boolean rotateLargestFootprint(int w, int d, int h) {\n\t\tint a = Integer.MIN_VALUE;\n\t\tif(heightUp(w, d, h)) {\n\t\t\ta = width * depth;\n\t\t}\n\n\t\tint b = Integer.MIN_VALUE;\n\t\tif(widthUp(w, d, h)) {\n\t\t\tb = height * depth;\n\t\t}\n\n\t\tint c = Integer.MIN_VALUE;\n\t\tif(depthUp(w, d, h)) {\n\t\t\tc = width * height;\n\t\t}\n\t\t\n\t\tif(a == Integer.MIN_VALUE && b == Integer.MIN_VALUE && c == Integer.MIN_VALUE) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(a > b && a > c) {\n\t\t\t// no rotate\n\t\t} else if(b > c) {\n\t\t\t// rotate once\n\t\t\trotate3D();\n\t\t} else {\n\t\t\trotate3D();\n\t\t\trotate3D();\n\t\t}\n\n\t\tif(h < height) {\n\t\t\tthrow new IllegalArgumentException(\"Expected height \" + height + \" to fit within height constraint \" + h);\n\t\t}\n\n\t\tif(width > w || depth > d) {\n\t\t\t// use the other orientation\n\t\t\trotate2D();\n\t\t}\n\t\t\n\t\tif(width > w || depth > d) {\n\t\t\tthrow new IllegalArgumentException(\"Expected width \" + width + \" and depth \" + depth + \" to fit within constraint width \" + w + \" and depth \" + d);\n\t\t}\n\n\t\treturn true;\n\t\t\n\t}\n","Extracted Method":"\tprivate boolean heightUp(int w, int d, int h) {\n\n\t\tif(h < height) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn (d >= width && w >= depth) || (w >= width && d >= depth);\n\t}\n"}
{"Smelly Sample":"\tpublic boolean rotateLargestFootprint(int w, int d, int h) {\n\t\tint a = -1;\n\t\tif(w >= width && h >= height && d >= depth) {\n\t\t\ta = width * depth;\n\t\t}\n\n\t\tint b = -1;\n\t\tif(h >= width && d >= height && w >= depth) {\n\t\t\tb = height * depth;\n\t\t}\n\n\t\tint c = -1;\n\t\tif(d >= width && w >= height && h >= depth) {\n\t\t\tc = width * height;\n\t\t}\n\t\t\n\t\tif(a == -1 && b == -1 && c == -1) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(a > b && a > c) {\n\t\t\t// no rotate\n\t\t} else if(b > c) {\n\t\t\t// rotate once\n\t\t\trotate3D();\n\t\t} else {\n\t\t\trotate3D();\n\t\t\trotate3D();\n\t\t}\n\n\t\treturn true;\n\t\t\n\t}\n","Method after Refactoring":"\tpublic boolean rotateLargestFootprint(int w, int d, int h) {\n\t\tint a = Integer.MIN_VALUE;\n\t\tif(heightUp(w, d, h)) {\n\t\t\ta = width * depth;\n\t\t}\n\n\t\tint b = Integer.MIN_VALUE;\n\t\tif(widthUp(w, d, h)) {\n\t\t\tb = height * depth;\n\t\t}\n\n\t\tint c = Integer.MIN_VALUE;\n\t\tif(depthUp(w, d, h)) {\n\t\t\tc = width * height;\n\t\t}\n\t\t\n\t\tif(a == Integer.MIN_VALUE && b == Integer.MIN_VALUE && c == Integer.MIN_VALUE) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\tif(a > b && a > c) {\n\t\t\t// no rotate\n\t\t} else if(b > c) {\n\t\t\t// rotate once\n\t\t\trotate3D();\n\t\t} else {\n\t\t\trotate3D();\n\t\t\trotate3D();\n\t\t}\n\n\t\tif(h < height) {\n\t\t\tthrow new IllegalArgumentException(\"Expected height \" + height + \" to fit within height constraint \" + h);\n\t\t}\n\n\t\tif(width > w || depth > d) {\n\t\t\t// use the other orientation\n\t\t\trotate2D();\n\t\t}\n\t\t\n\t\tif(width > w || depth > d) {\n\t\t\tthrow new IllegalArgumentException(\"Expected width \" + width + \" and depth \" + depth + \" to fit within constraint width \" + w + \" and depth \" + d);\n\t\t}\n\n\t\treturn true;\n\t\t\n\t}\n","Extracted Method":"\tprivate boolean widthUp(int w, int d, int h) {\n\n\t\tif(h < width) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn (d >= height && w >= depth) || (w >= height && d >= depth);\n\t}\n"}
{"Smelly Sample":"\tpublic boolean rotateSmallestFootprint(int w, int d, int h) {\n\t\tint a = Integer.MAX_VALUE;\n\t\tif(w >= width && h >= height && d >= depth) {\n\t\t\ta = width * depth;\n\t\t}\n\n\t\tint b = Integer.MAX_VALUE;\n\t\tif(h >= width && d >= height && w >= depth) {\n\t\t\tb = height * depth;\n\t\t}\n\n\t\tint c = Integer.MAX_VALUE;\n\t\tif(d >= width && w >= height && h >= depth) {\n\t\t\tc = width * height;\n\t\t}\n\t\t\n\t\tif(a == Integer.MAX_VALUE && b == Integer.MAX_VALUE && c == Integer.MAX_VALUE) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(a < b && a < c) {\n\t\t\t// no rotate\n\t\t} else if(b < c) {\n\t\t\t// rotate once\n\t\t\trotate3D();\n\t\t} else {\n\t\t\trotate3D();\n\t\t\trotate3D();\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n","Method after Refactoring":"\tpublic boolean rotateSmallestFootprint(int w, int d, int h) {\n\t\tint a = Integer.MAX_VALUE;\n\t\tif(heightUp(w, d, h)) {\n\t\t\ta = width * depth;\n\t\t}\n\n\t\tint b = Integer.MAX_VALUE;\n\t\tif(widthUp(w, d, h)) {\n\t\t\tb = height * depth;\n\t\t}\n\n\t\tint c = Integer.MAX_VALUE;\n\t\tif(depthUp(w, d, h)) {\n\t\t\tc = width * height;\n\t\t}\n\n\t\tif(a == Integer.MAX_VALUE && b == Integer.MAX_VALUE && c == Integer.MAX_VALUE) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(a < b && a < c) {\n\t\t\t// no rotate\n\t\t} else if(b < c) {\n\t\t\t// rotate once\n\t\t\trotate3D();\n\t\t} else {\n\t\t\trotate3D();\n\t\t\trotate3D();\n\t\t}\n\t\t\n\t\tif(h < height) {\n\t\t\tthrow new IllegalArgumentException(\"Expected height \" + height + \" to fit within height constraint \" + h);\n\t\t}\n\n\t\tif(width > w || depth > d) {\n\t\t\t// use the other orientation\n\t\t\trotate2D();\n\t\t}\n\t\t\n\t\tif(width > w || depth > d) {\n\t\t\tthrow new IllegalArgumentException(\"Expected width \" + width + \" and depth \" + depth + \" to fit within constraint width \" + w + \" and depth \" + d);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n","Extracted Method":"\tprivate boolean heightUp(int w, int d, int h) {\n\n\t\tif(h < height) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn (d >= width && w >= depth) || (w >= width && d >= depth);\n\t}\n"}
{"Smelly Sample":"\tpublic boolean rotateSmallestFootprint(int w, int d, int h) {\n\t\tint a = Integer.MAX_VALUE;\n\t\tif(w >= width && h >= height && d >= depth) {\n\t\t\ta = width * depth;\n\t\t}\n\n\t\tint b = Integer.MAX_VALUE;\n\t\tif(h >= width && d >= height && w >= depth) {\n\t\t\tb = height * depth;\n\t\t}\n\n\t\tint c = Integer.MAX_VALUE;\n\t\tif(d >= width && w >= height && h >= depth) {\n\t\t\tc = width * height;\n\t\t}\n\t\t\n\t\tif(a == Integer.MAX_VALUE && b == Integer.MAX_VALUE && c == Integer.MAX_VALUE) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(a < b && a < c) {\n\t\t\t// no rotate\n\t\t} else if(b < c) {\n\t\t\t// rotate once\n\t\t\trotate3D();\n\t\t} else {\n\t\t\trotate3D();\n\t\t\trotate3D();\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n","Method after Refactoring":"\tpublic boolean rotateSmallestFootprint(int w, int d, int h) {\n\t\tint a = Integer.MAX_VALUE;\n\t\tif(heightUp(w, d, h)) {\n\t\t\ta = width * depth;\n\t\t}\n\n\t\tint b = Integer.MAX_VALUE;\n\t\tif(widthUp(w, d, h)) {\n\t\t\tb = height * depth;\n\t\t}\n\n\t\tint c = Integer.MAX_VALUE;\n\t\tif(depthUp(w, d, h)) {\n\t\t\tc = width * height;\n\t\t}\n\n\t\tif(a == Integer.MAX_VALUE && b == Integer.MAX_VALUE && c == Integer.MAX_VALUE) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(a < b && a < c) {\n\t\t\t// no rotate\n\t\t} else if(b < c) {\n\t\t\t// rotate once\n\t\t\trotate3D();\n\t\t} else {\n\t\t\trotate3D();\n\t\t\trotate3D();\n\t\t}\n\t\t\n\t\tif(h < height) {\n\t\t\tthrow new IllegalArgumentException(\"Expected height \" + height + \" to fit within height constraint \" + h);\n\t\t}\n\n\t\tif(width > w || depth > d) {\n\t\t\t// use the other orientation\n\t\t\trotate2D();\n\t\t}\n\t\t\n\t\tif(width > w || depth > d) {\n\t\t\tthrow new IllegalArgumentException(\"Expected width \" + width + \" and depth \" + depth + \" to fit within constraint width \" + w + \" and depth \" + d);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n","Extracted Method":"\tprivate boolean widthUp(int w, int d, int h) {\n\n\t\tif(h < width) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn (d >= height && w >= depth) || (w >= height && d >= depth);\n\t}\n"}
